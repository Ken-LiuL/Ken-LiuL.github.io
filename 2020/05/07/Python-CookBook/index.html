<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://ken-liul.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":true,"storage":true,"lazyload":false,"nav":{"valine":{"text":"Load Valine","order":3}}},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Python是一门非常好作为入门学习的编程语言，语言简洁干练，拥有强大的第三方库，可以用来做机器学习、数据分析、爬虫等等。但是，很多人入门之后对Python的认知就停留在了比较浅显的认知上，成为了调包侠， Python本身有一些特性和库（如collections、future、generator等）是值得并且需要仔细来琢磨的。Python Cookbook 就是一本可以作为进阶学习Python的书">
<meta property="og:type" content="article">
<meta property="og:title" content="Python CookBook">
<meta property="og:url" content="https://ken-liul.github.io/2020/05/07/Python-CookBook/index.html">
<meta property="og:site_name" content="kenliu&#39;s blog">
<meta property="og:description" content="Python是一门非常好作为入门学习的编程语言，语言简洁干练，拥有强大的第三方库，可以用来做机器学习、数据分析、爬虫等等。但是，很多人入门之后对Python的认知就停留在了比较浅显的认知上，成为了调包侠， Python本身有一些特性和库（如collections、future、generator等）是值得并且需要仔细来琢磨的。Python Cookbook 就是一本可以作为进阶学习Python的书">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-07T07:31:33.000Z">
<meta property="article:modified_time" content="2020-07-10T15:14:27.846Z">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ken-liul.github.io/2020/05/07/Python-CookBook/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Python CookBook | kenliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">kenliu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">tech && life</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Ken-LiuL" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ken-liul.github.io/2020/05/07/Python-CookBook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kenliu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python CookBook
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-07 15:31:33" itemprop="dateCreated datePublished" datetime="2020-05-07T15:31:33+08:00">2020-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-10 23:14:27" itemprop="dateModified" datetime="2020-07-10T23:14:27+08:00">2020-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/05/07/Python-CookBook/" class="post-meta-item leancloud_visitors" data-flag-title="Python CookBook" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
                 
                <span class="post-meta-item-text">阅读次数&#58;</span>
                 
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/05/07/Python-CookBook/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/05/07/Python-CookBook/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Python是一门非常好作为入门学习的编程语言，语言简洁干练，拥有强大的第三方库，可以用来做机器学习、数据分析、爬虫等等。但是，很多人入门之后对Python的认知就停留在了比较浅显的认知上，成为了调包侠， Python本身有一些特性和库（如collections、future、generator等）是值得并且需要仔细来琢磨的。<a href="https://book.douban.com/subject/4828875/" target="_blank" rel="noopener">Python Cookbook</a> 就是一本可以作为进阶学习Python的书籍，里面的很多技巧和方法论非常实用。</p>
<a id="more"></a>

<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="序列分解"><a href="#序列分解" class="headerlink" title="序列分解"></a>序列分解</h2><p>任何的序列（或者是可迭代对象）可以通过一个简单的赋值操作来分解为单独的变量, 如果变量总数和序列里的元素数目不匹配会抛出ValueError，不过我们可以用*操作符来处理这种情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y, z = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = a</span><br><span class="line">ValueError: too many values to unpack (expected <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*x, y = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, *_, y = a  <span class="comment">#如果你想丢弃部分元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deque可以以O(1)的时间复杂度在头部和尾部进行append和pop的操作，既可以作为queue也可以作为stack来使用。</p>
<blockquote>
<p>Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.popleft()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="Heapq"><a href="#Heapq" class="headerlink" title="Heapq"></a>Heapq</h2><p>Heapq就是堆数据结构（也叫优先队列），他满足<strong>heap[k] &lt;= heap[2<em>k+1] and heap[k] &lt;= heap[2</em>k+2]</strong>, heapq是最小堆， heapq[0]得到的总是最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums)) <span class="comment"># Prints [42, 37, 23]</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums)) <span class="comment"># Prints [-4, 1, 2]</span></span><br><span class="line"><span class="comment">#优先队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._queue = []</span><br><span class="line">        self._index = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item, priority)</span>:</span></span><br><span class="line">        heapq.heappush(self._queue, (-priority, item, self._index))</span><br><span class="line">        self._index += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(self._queue)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>heap[0]和heapq.heappop()操作永远得到当前最小的元素，每次操作的时间复杂度仅仅为logN，所以当需要得到n个最小的元素并且n远远小于列表的长度的时候，通过heapq来实现是比较好的。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>常常我们想要一个key对应多个值，容易写出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> v <span class="keyword">in</span> d:</span><br><span class="line">    d[v].append()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    d[v] = []</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">d.setdefault(v, []).append()</span><br></pre></td></tr></table></figure>
<p>这样的代码块，setdefault相对方便一点，但是每次都要调用很繁琐，其实我们可以直接用<strong>defaultdict</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d = defaultdict()</span><br><span class="line">d[<span class="string">'test'</span>].append(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<p>而有的时候当我们迭代字典的时候希望能够保留插入的顺序，那么可以使用<strong>OrderedDict</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">d = OrderedDict()</span><br><span class="line">d[<span class="string">'test1'</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">'test2'</span>] = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure>
<p>如果要比较字典的键值的相同或者不同，也有方便的集合操作符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.keys() &amp; b.keys()   <span class="comment">#intersection</span></span><br><span class="line">a.keys() - b.keys()   <span class="comment">#difference</span></span><br><span class="line">a.items() &amp; b.items()</span><br><span class="line">a.items() - b.items()</span><br></pre></td></tr></table></figure>
<p>需要注意的是<strong>a.values()</strong>方法并不支持这样的集合操作。</p>
<h2 id="命名切片"><a href="#命名切片" class="headerlink" title="命名切片"></a>命名切片</h2><p>在做数据处理的时候，常常需要频繁的对序列进行切片，满屏幕的切片操作常常会让代码可读性大大降低，命名切片可以提高代码可读性和维护性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = slice(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>) <span class="comment">#start, stop, step</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[a]</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.indices(<span class="number">5</span>)       <span class="comment">#适配一个合适的范围</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="制表或者计数"><a href="#制表或者计数" class="headerlink" title="制表或者计数"></a>制表或者计数</h2><p>对于字典而言，一个常见的用法是，我们经常用来统计元素的频率</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> dic:</span><br><span class="line">    <span class="keyword">if</span> e <span class="keyword">in</span> dic:</span><br><span class="line">        dic[e] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[e] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>不过其实python的<strong>Counter</strong>可以直接用来解决此类问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">fre = Counter(a)</span><br><span class="line">fre.most_common(<span class="number">3</span>)          <span class="comment">#top 3 出现的元素</span></span><br><span class="line"><span class="comment">#一个有意思的地方是，Counter可以直接做数学操作</span></span><br><span class="line">fre2 = Counter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">fre - fre2                 <span class="comment">#difference</span></span><br><span class="line">fre + fre2                 <span class="comment">#union</span></span><br></pre></td></tr></table></figure>
<h2 id="字典和对象排序"><a href="#字典和对象排序" class="headerlink" title="字典和对象排序"></a>字典和对象排序</h2><p>如果需要对数组字典进行排序的话，我们常常的做法是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(data, key=<span class="keyword">lambda</span>...)</span><br></pre></td></tr></table></figure>
<p>python其实提供一个专门的函数来处理这种情况，<strong>itemgetter</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">sroted(data, key=itemgetter(<span class="string">'field1'</span>, <span class="string">'field2'</span>))</span><br><span class="line"><span class="comment">#min,max也可以使用</span></span><br><span class="line">max(l, key=itemgetter(<span class="string">'field1))</span></span><br></pre></td></tr></table></figure>
<p>类似得，如果是对数组对象进行排序的话，我们可以使用<strong>attrgetter</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line">sorted(users, key=attrgetter(<span class="string">'user_id'</span>))</span><br></pre></td></tr></table></figure>
<p>值得注意是，虽然两种做法都可以，但是来自operator的做法会更快一点</p>
<h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><p>常用的数据分组我们会用pandas来进行，其实python的itertools包也提供类似的功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line">data.sort(key=itemgetter(<span class="string">'user_id'</span>))</span><br><span class="line">groupby(data, key=itemgetter(<span class="string">'user_id'</span>))</span><br></pre></td></tr></table></figure>
<p>值得注意的地方是，<strong>groupby</strong>的逻辑是检查连续的元素，所以事先我们需要对数据进行第一轮排序。</p>
<h2 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h2><p>数据过滤有很多做法，除去简单的for loop，我们可以使用过滤器、迭代器、生成器以及itertool里面的工具</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[n <span class="keyword">for</span> n <span class="keyword">in</span> l <span class="keyword">if</span> n &gt; <span class="number">0</span>]        <span class="comment">#list comprehension</span></span><br><span class="line">(n <span class="keyword">for</span> n <span class="keyword">in</span> l <span class="keyword">if</span> n &gt; <span class="number">0</span>)        <span class="comment">#generator </span></span><br><span class="line">list(filter(<span class="keyword">lambda</span> x:.., l))   <span class="comment">#filter</span></span><br><span class="line">[n <span class="keyword">if</span> n &gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">for</span> n <span class="keyword">in</span> l] <span class="comment">#transformation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = [ i &gt; <span class="number">5</span> <span class="keyword">for</span> i <span class="keyword">in</span> a]</span><br><span class="line">list(compress(a, b))            <span class="comment">#根据b中的布尔值过滤对应的元素</span></span><br></pre></td></tr></table></figure>
<h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><p>当需要频繁大量的通过下标来访问tuple的时候，我们可以使用namedtuple来提高程序的可读性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User = namedtuple(<span class="string">'User'</span>, [<span class="string">'user_id'</span>, <span class="string">'username'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = User(<span class="string">'no1'</span>, <span class="string">'jacky'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.username</span><br><span class="line">jacky</span><br></pre></td></tr></table></figure>
<h2 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h2><p>合并字典也是常见的操作之一，我们经常会写if代码块来做这样的工作，或者使用update方法，这样会创建一个新的字典，但是其实可以直接使用 ChainMap来处理字典的合并查询，合成的新对象只是两个字典逻辑上的合并，并没有新的字典对象被创造出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'z'</span>:<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">'y'</span>:<span class="number">2</span>, <span class="string">'z'</span>:<span class="number">4</span>&#125;</span><br><span class="line">b.update(a)        <span class="comment">#用a来覆盖b，相同的key的话，会采用a中的值  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">a = &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'z'</span>:<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">'y'</span>:<span class="number">2</span>, <span class="string">'z'</span>:<span class="number">4</span>&#125;</span><br><span class="line">c = ChainMap(a, b)   <span class="comment">#用a来覆盖b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ChainMap一个有意思的地方是可以很方便的作为编程语言作用域的处理</span></span><br><span class="line">env = ChainMap()</span><br><span class="line">env[<span class="string">'x'</span>] = <span class="number">1</span></span><br><span class="line">env = env.new_child()</span><br><span class="line">env[<span class="string">'x'</span>] = <span class="number">2</span></span><br><span class="line">env = env.new_child()</span><br><span class="line"><span class="comment">#现在env['x']等于2</span></span><br><span class="line">env = env.parents</span><br><span class="line"><span class="comment">#现在env['x']等于1</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><p>几乎所有有用的程序都会涉及到某些文本处理，不管是解析数据还是产生输出。 这一章将重点关注文本的操作处理，比如提取字符串，搜索，替换以及解析等。</p>
<h2 id="字符串分割匹配和搜索"><a href="#字符串分割匹配和搜索" class="headerlink" title="字符串分割匹配和搜索"></a>字符串分割匹配和搜索</h2><p><strong>string</strong>对象的<strong>split</strong>方法适用范围比较狭窄，而<strong>re.split</strong>则可以适用更广范围的字符串分割</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"a   b   c"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.split(<span class="string">' '</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'c'</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, a)</span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="comment">#re.split还可以进行多字符分割</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'asdf fjdk; afed, fjek,asdf, foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[;,\s]\s*'</span>, a)</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">'fjdk'</span>, <span class="string">'afed'</span>, <span class="string">'fjek'</span>, <span class="string">'asdf'</span>, <span class="string">'foo'</span>]</span><br></pre></td></tr></table></figure>
<p>同理，对于<strong>replace</strong>方法，我们也可以使用<strong>re.sub</strong>来实现更高级的文本替代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>, <span class="string">r'\3-\1-\2'</span>, a)</span><br><span class="line"><span class="string">'Today is 2012-11-27. PyCon starts 2013-3-13.'</span></span><br><span class="line"><span class="comment">#我们还可以使用命名分组来实现上述的功能</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(?P&lt;month&gt;\d+)/(?P&lt;day&gt;\d+)/(?P&lt;year&gt;\d+)'</span>, <span class="string">r'\g&lt;year&gt;-\g&lt;month&gt;-\g&lt;day&gt;'</span>, a)</span><br><span class="line"><span class="string">'Today is 2012-11-27. PyCon starts 2013-3-13.'</span></span><br><span class="line"><span class="comment">#更高级点的用法， 是可以传入回掉函数来处理sub</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(\d+)\(\d+)\(\d+)'</span>, <span class="keyword">lambda</span> x:x, a)</span><br></pre></td></tr></table></figure>
<p>在匹配中我们可以用?如(.*?)来做最短匹配，也可以使用?:如(?:\d+)来指定一个非捕获匹配。</p>
<h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>我们可以使用<strong>rjust()</strong>，<strong>ljust()</strong> 以及 <strong>center()</strong> 来做字符串对齐，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.ljust(<span class="number">20</span>)</span><br><span class="line"><span class="string">'Hello World         '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.rjust(<span class="number">20</span>)</span><br><span class="line"><span class="string">'         Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.center(<span class="number">20</span>, <span class="string">'*'</span>)</span><br><span class="line"><span class="string">'****Hello World*****'</span></span><br></pre></td></tr></table></figure>

<p><strong>format()</strong> 也可以做到这一点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'&gt;20'</span>)</span><br><span class="line"><span class="string">'         Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'&lt;20'</span>)</span><br><span class="line"><span class="string">'Hello World         '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'^20'</span>)</span><br><span class="line"><span class="string">'    Hello World     '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'=&gt;20s'</span>)</span><br><span class="line"><span class="string">'=========Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;:&gt;10s&#125; &#123;:&gt;10s&#125;'</span>.format(<span class="string">'Hello'</span>, <span class="string">'World'</span>)</span><br><span class="line"><span class="string">'     Hello      World'</span></span><br></pre></td></tr></table></figure>

<p>而且，我们还可以通过<strong>textwrap</strong> 模块来控制输出字符串的列宽</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line">textwrap.fill(s, <span class="number">40</span>)</span><br><span class="line"><span class="comment">#还可以配合os.get_terminal_size()来格式化输出</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">col = os.get_terminal_size().columns</span><br><span class="line">textwrap.fill(s, col)</span><br></pre></td></tr></table></figure>
<h1 id="数字日期和时间"><a href="#数字日期和时间" class="headerlink" title="数字日期和时间"></a>数字日期和时间</h1><h2 id="数字的格式化"><a href="#数字的格式化" class="headerlink" title="数字的格式化"></a>数字的格式化</h2><p>如果需要对浮点数进行四舍五入，我们可以直接使用<strong>round</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.23</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.27</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1644</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="number">1640</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1655</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="number">1700</span></span><br></pre></td></tr></table></figure>
<p>众所周知，浮点数计算是会存在误差的，所以如果需要更精确的浮点数计算，我们可以使用<strong>Decimal</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Decimal(<span class="string">'4.2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Decimal(<span class="string">'2.1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a / b</span><br><span class="line">Decimal(<span class="string">'3.333333333333333333333333333'</span>)</span><br><span class="line"><span class="comment">#还可以控制计算的规范</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> localcontext</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="keyword">with</span> localcontext() <span class="keyword">as</span> ctx:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   ctx.prec = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   print(a / b)</span><br><span class="line"><span class="number">3.33</span></span><br></pre></td></tr></table></figure>
<p>数字进制进行转换的时候，我们常常使用<strong>bin()</strong> ， <strong>orc()</strong> 以及 <strong>hex()</strong> ， 但<strong>format</strong>也可以完成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(x)</span><br><span class="line"><span class="string">'0b10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(x)</span><br><span class="line"><span class="string">'0o2322'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(x)</span><br><span class="line"><span class="string">'0x4d2'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'b'</span>)</span><br><span class="line"><span class="string">'10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'o'</span>)</span><br><span class="line"><span class="string">'2322'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'x'</span>)</span><br><span class="line"><span class="string">'4d2'</span></span><br><span class="line"><span class="comment">#反过来可以直接用int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> int(<span class="string">'10011010010'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h2 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h2><p><strong>random</strong> 模块有很多函数来进行随机选择或者生成元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice(values)  <span class="comment">#随机选择</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(values, <span class="number">3</span>) <span class="comment">#随机抽样</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle()   <span class="comment">#随机打乱</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">0</span>, <span class="number">10</span>) <span class="comment">#随机数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()  <span class="comment"># 0 - 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.getrandbits(<span class="number">2</span>) <span class="comment">#N bit 随机数</span></span><br></pre></td></tr></table></figure>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>python的datetime是一个模块，有好几个类用来进行时间和日期的操作</p>
<ul>
<li>date 日期类</li>
<li>time 时间类</li>
<li>datetime 日期时间</li>
<li>timedelta 表示时间差</li>
<li>tzinfo  时区信息</li>
<li>timezone  时区</li>
</ul>
<p>用datetime和timedelta可以进行时间计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta, datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">23</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a + timedelta(days=<span class="number">10</span>))</span><br><span class="line"><span class="number">2012</span><span class="number">-10</span><span class="number">-03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = datetime(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b - a</span><br><span class="line">datetime.timedelta(days=<span class="number">89</span>)</span><br></pre></td></tr></table></figure>
<p>字符串转为时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class="string">'2020-12-01 19:23:23'</span>, <span class="string">'%Y-%m-%d, %H:%M:%S'</span>)</span><br></pre></td></tr></table></figure>
<p>时间格式化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(now.strftime(<span class="string">'%a, %b %d %H:%M'</span>))</span><br></pre></td></tr></table></figure>
<p>时区的设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tz = timezone(timedelta(hours=<span class="number">8</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = now.astimezone(tz)</span><br></pre></td></tr></table></figure>
<p> 需要注意的一点是, <strong>strptime</strong> 性能并不好，并且关于时区的问题，最好是使用<strong>pytz</strong> 模块<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>central = timezone(<span class="string">'US/Central)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; now = central.localize(datetime.now()) #得到美国时区的当前时间</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;  now.astimezone(timezone('</span>Asia/Shanghai<span class="string">')) #得到上海时区</span></span><br></pre></td></tr></table></figure><br><strong>pytz</strong> 是一个第三方库，需要安装</p>
<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p>迭代器其实就是实现了迭代协议的对象，任何一个实现了<strong>next</strong>方法的对象都是一个迭代器，我们常常会把<strong>iter</strong>也实现了，当调用iter(obj)的时候，其实就是调用了对象的<strong>iter</strong>方法 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.val = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.val += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.val &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">return</span> self.val</span><br><span class="line">it  = iter(Iter())</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> it:</span><br><span class="line">    print(it)</span><br></pre></td></tr></table></figure>
<p>那生成器是什么呢？<strong>yield</strong>就构建了一个生成器，生成器实现了迭代器协议</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_range</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range_():</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>上面的<strong>my_range</strong>就是一个生成器，调用<strong>my_range()</strong> 之后会返回一个Generator对象，这个对象就实现了迭代器协议，可以进行各种迭代器的操作。如果我们想要对实现了迭代器协议的对象进行切片操作的话，那么就需要使用<strong>itertools.islice()</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.islice(g, <span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p><strong>itertools</strong> 中还有用于过滤数据的<strong>dropwhile</strong> 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dropwhile(<span class="keyword">lambda</span> x: x &lt; <span class="number">5</span>, a):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#会打印出来5, 6, 7, 8, 9</span></span><br><span class="line"><span class="comment">#dropwhile会从前往后读数据，直到遇到第一个False，那么就会输出后续的所有元素</span></span><br><span class="line"><span class="comment">#值得注意的是这里只会处理第一个False</span></span><br></pre></td></tr></table></figure>
<p><strong>itertools</strong> 中还有有很多有用的处理迭代器对象的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations, combinations, zip_longest, chain</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(permutations(a))    <span class="comment">#排列</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(combinations(a, <span class="number">2</span>))    <span class="comment">#组合</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip_longest([<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">#返回最长的zip结果，默认的zip是最短的</span></span><br><span class="line">&gt;&gt;&gt;chain([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]) <span class="comment">#从逻辑上组合多个迭代器对象，然后进行统一的操作</span></span><br></pre></td></tr></table></figure>
<p><strong>iter</strong> 还有一个用法是可以接受一个函数，和结尾标记作为输入参数，它会创建一个迭代器，然后不对调用该函数，直到返回的是结尾标记</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> iter(<span class="keyword">lambda</span> : a.pop(), <span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="Yield"><a href="#Yield" class="headerlink" title="Yield"></a>Yield</h2><p>我们可以通过<strong>yield</strong>来得到一个生成器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>
<p>如果需要嵌套生成器，那么需要使用<strong>yield from</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> gen()</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gen():</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>
<p><strong>yield</strong>的使用中，一个难点或者说容易产生误解的地方是，当他和<strong>send</strong>一起使用的时候</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">ys</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>   i = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>       a = <span class="keyword">yield</span> i</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">if</span> a &gt; <span class="number">10</span>:</span><br><span class="line"><span class="meta">... </span>           <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>       i = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ys()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(g.send(<span class="literal">None</span>))</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(g.send(<span class="number">1</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(g.send(<span class="number">20</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>首先<strong>next</strong>和<strong>send(None)</strong> 是等价的，所以<strong>g.send(None)</strong> 等价于 <strong>next(g)</strong> ，关键的地方在于<strong>a = yield i</strong>这一行是怎么执行的，当我们第一次调用<strong>g.send(None)</strong> 的时候， 程序会运行到<strong>yield i</strong>这里，也就是会把<strong>i</strong>的值，当然此时是0，返回出来，所以打印出来的结果为0，然后此时程序挂起，值得注意的是此时变量<strong>a</strong>并没有得到任何的赋值，然后当调用<strong>g.send(1)</strong> 的时候，程序恢复执行，把1赋值给<strong>a</strong>然后程序一直运行到下一个<strong>yield</strong>的地方，此时<strong>i</strong>为1，那么也就会把1返回出去并打印出来。当<strong>g.send(20)</strong>的时候，<strong>a</strong>被赋值为20，然后循环会退出，那么我们就看到<strong>StopIteration</strong>被抛出来了。</p>
<h1 id="文件与IO"><a href="#文件与IO" class="headerlink" title="文件与IO"></a>文件与IO</h1><h2 id="文件写入和打印"><a href="#文件写入和打印" class="headerlink" title="文件写入和打印"></a>文件写入和打印</h2><p><strong>print</strong>最常用的输出函数，当使用<strong>print</strong>的时候，我们可以使用<strong>sep</strong>和<strong>end</strong>两个关键字参数来格式化输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;print(<span class="string">'hello'</span>, <span class="string">'world'</span>, sep=<span class="string">','</span>, end=<span class="string">'!!\n'</span>)</span><br><span class="line">hello,world!!</span><br></pre></td></tr></table></figure>
<p>一个常见的写文件的方式为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file'</span>, <span class="string">'w+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们需要追加到既有的文件中，那就需要使用<strong>a</strong>模式，但是如果我们想要只有该文件不存在的时候才写入，一种方式是显示判断文件是否存在，另外一种方式是指定模式为<strong>x</strong></p>
<h2 id="字符串IO"><a href="#字符串IO" class="headerlink" title="字符串IO"></a>字符串IO</h2><p>可以使用<strong>io.StringIO()</strong>和<strong>io.BytesIO()</strong> 来创建类文件对象操作字符串数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = io.StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.write(<span class="string">'Hello World\n'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'This is a test'</span>, file=s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.getvalue()</span><br><span class="line"><span class="string">'Hello World\nThis is a test\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = io.BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.write(<span class="string">b'binary data'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.getvalue()</span><br><span class="line"><span class="string">b'binary data'</span></span><br></pre></td></tr></table></figure>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>mmap可以让我们想操作内存一样操作文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#打开一个文件，并且使用mmap映射到内存里</span></span><br><span class="line">mapped = mmap.mmap(os.open(filename, os.O_RDWR), os.path.getsize(filename), access=mmap.ACCESS_WRITE)</span><br><span class="line"><span class="comment">#如果第一个参数设为-1，那么映射的是一段匿名内存</span></span><br><span class="line"><span class="keyword">with</span> mmap.mmap(<span class="number">-1</span>, <span class="number">13</span>) <span class="keyword">as</span> mm:</span><br><span class="line">    mm.write(<span class="string">b'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>对于文件路径的操作，<strong>os.path</strong>提供了很多方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">'/users/test/data/data.csv'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.basename(path)</span><br><span class="line"><span class="string">'data.csv'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.dirname(path)</span><br><span class="line"><span class="string">'/users/test/data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">'/test'</span>, <span class="string">'data'</span>)</span><br><span class="line"><span class="string">'/test/data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exits(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.islink(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getsize(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getmtime(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">'/test'</span>)</span><br></pre></td></tr></table></figure>
<p>python3.4版本之后引入了<strong>pathlib</strong>这个包，用这个包可以让我们用更优雅的方式来处理文件路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#旧方式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"><span class="comment">#pathlib可以以面向对象的方式来调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base_dir = Path(__file__).resolve().parent.parent</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path = base_dir / <span class="string">'data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.is_dir()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.is_file()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.is_symlink()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path..absolute()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.exits()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment">#使用pathlib还可以直接读取文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.read_text()</span><br></pre></td></tr></table></figure>
<p>相比较<strong>os.path</strong>的方式而言，<strong>pathlib</strong>显得更更干净利落</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>如果需要使用临时文件，我们可以自己显示的管理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp_file  = tempfile.mkstemp()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp_dir = tempfile.mkdtemp()</span><br></pre></td></tr></table></figure>
<p>但是这样仅仅是创建了临时的文件和文件夹，我们需要自己处理打开，关闭和删除操作，更好的方式是使用<strong>TemporaryFile</strong>或<strong>NamedTemporaryFile</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryFile, NamedTemporaryFile</span><br><span class="line"><span class="keyword">with</span> TemporaryFile(<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'test'</span>)</span><br><span class="line"><span class="comment">#如果使用NamedTemporaryFile的话，还会额外的分配临时文件的名字出来</span></span><br><span class="line"><span class="keyword">with</span> NamedTemporaryFile(<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.name)</span><br></pre></td></tr></table></figure>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="对象的显示"><a href="#对象的显示" class="headerlink" title="对象的显示"></a>对象的显示</h2><p>对于python的类而言，有三个函数可以指定其输出的时候的样子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="comment">#str()函数，或者print的时候调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#在控制台操作的时候打印出来的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#format()的时候调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="上下文管理协议"><a href="#上下文管理协议" class="headerlink" title="上下文管理协议"></a>上下文管理协议</h2><p>如果想要自己创建的类支持<strong>with</strong>语句的话，需要实现<strong>enter</strong> 和<strong>exit</strong>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#第一个参数是异常类型</span></span><br><span class="line">    <span class="comment">#第二个参数是异常值</span></span><br><span class="line">    <span class="comment">#第三个参数是stacktrace</span></span><br><span class="line">    <span class="comment">#如果返回True，异常会被清空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, tb)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p> 同时，我们也可以从contextlib库中来使用contextmanager更好的来做上下文管理<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> contextlib</span><br><span class="line"><span class="meta"> @contextlib.contextmanager</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">open_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    f = open(filename, <span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">yield</span> f</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open_file(<span class="string">'test'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.readlines()</span><br></pre></td></tr></table></figure><br> contextmanager会把yield之前的内容作为<strong>enter</strong>， yield之后的内容作为<strong>exit</strong>，yield返回的内容作为as</p>
<h2 id="节省内存的方式创建对象"><a href="#节省内存的方式创建对象" class="headerlink" title="节省内存的方式创建对象"></a>节省内存的方式创建对象</h2><p> 当我们使用<strong>slots</strong>的时候可以有效节省对象占用的内存，因为内部会用tuple而不是字典来存储对应的属性<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">   __slots__ = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b, c)</span>:</span></span><br><span class="line">       sefl.a = a</span><br><span class="line">       self.b = b</span><br><span class="line">       self.c = c</span><br></pre></td></tr></table></figure><br> 但是如果使用了<strong>slots</strong>会有两个限制，一个是不支持多继承，另外一个是无法再给是例添加属性</p>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>以_和<strong>开头的属性都可被视为私有属性，区别是</strong>开头的属性会被重命名，所以继承的话无法被覆盖，大部分情况用_开头即可表面这是一个内部属性<br>##属性访问<br>python中可以像java等面向对象的语言一样设置属性的<strong>getter</strong>和<strong>setter</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self._name =self.name</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._name = value</span><br></pre></td></tr></table></figure>
<p>往往当我们想要给属性的访问添加额外的逻辑，比如验证的时候，可以采用这种方式，但是除此之外就没必要了，python不是java</p>
<h2 id="延迟属性和描述器"><a href="#延迟属性和描述器" class="headerlink" title="延迟属性和描述器"></a>延迟属性和描述器</h2><p>当使用<strong>lazyproperty</strong>的时候，属性仅仅在第一次被获取的时候被计算，以后都是直接获取值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"><span class="meta">    @lazyproperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.pi * self.radius ** <span class="number">2</span></span><br><span class="line"><span class="comment">#这里的area仅会计算一次</span></span><br></pre></td></tr></table></figure>
<p>实现了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__set__</span><br><span class="line">__get__</span><br><span class="line">__delete__</span><br></pre></td></tr></table></figure>
<p>中任意一个方法的对象就叫做描述器，python中很多特性都使用到了描述器，可以更好实现封装和隐藏实现细节</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositiveNum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span>  self._value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'No negative'</span>)</span><br><span class="line">        self._value = val</span><br></pre></td></tr></table></figure>
<p>上面的<strong>PositiveNum</strong>就是一个描述器，描述器作为其他类的类属性的时候，就会发挥他的作用了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>:</span></span><br><span class="line">    price = PositiveNum(<span class="string">'price'</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">apple = Apple()</span><br><span class="line">apple.price</span><br><span class="line"><span class="comment">#当我们访问这个price的时候，会去调用price.__get__方法</span></span><br><span class="line">apple.price = <span class="number">20</span></span><br><span class="line"><span class="comment">#当我们设置这个price的时候，会去调用price.__set__方法</span></span><br><span class="line">apple2 = Apple()</span><br><span class="line"><span class="comment">#但是这样会产生一个问题，由于price是类属性，新创建的apple2实例，</span></span><br><span class="line"><span class="comment">#price就是20，因为类属性共享</span></span><br></pre></td></tr></table></figure>
<p>python中属性的查找顺序是这样的，如果类和基类中有该属性且该属性为带有<strong>set</strong>的描述器（上面的price）就是这种情况，就调用对应的描述器的<strong>set</strong>和<strong>get</strong>方法，否则就是访问实例的字典。另外一点需要说明的是，实例的属性都放在<strong>dict</strong>里，类属性都放在<strong>dict</strong>里，实例的类型是<strong>class</strong>，那么我们可以这样处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositiveNum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, val)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.name] =  val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value has to be positive'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>:</span></span><br><span class="line">    price = PositiveNum(<span class="string">'price'</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.price = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">apple1 = Apple()</span><br><span class="line">apple1.price = <span class="number">20</span></span><br><span class="line">apple2 = Apple()</span><br><span class="line">apple2.price == <span class="number">1</span></span><br><span class="line"><span class="comment">#这里apple1和apple2的price是独立分开，不互相干扰的，</span></span><br><span class="line"><span class="comment">#当我们需要访问price的时候，由于在类级别拥有price描述器，所</span></span><br><span class="line"><span class="comment">#有的访问或者赋值都会转为去调用price.__set__或price.__get__，</span></span><br><span class="line"><span class="comment">#那既然还是调用__get__和__set__，为什么这一次不一样了？</span></span><br><span class="line"><span class="comment">#关键地方在            </span></span><br><span class="line"><span class="comment">#     instance.__dict__[self.name] =  val</span></span><br><span class="line"><span class="comment">#instance是属性的调用方，也就是apple1或者apple2，</span></span><br><span class="line"><span class="comment">#instance.__dict__就是例子的属性字典了，</span></span><br></pre></td></tr></table></figure>
<p><strong>所以描述器本质上就是切面编程的一种实现，可以把一些通用的操作提取出来，然后对对象的属性或方法做装饰</strong></p>
<h2 id="Method-amp-amp-Function"><a href="#Method-amp-amp-Function" class="headerlink" title="Method &amp;&amp; Function"></a>Method &amp;&amp; Function</h2><p>Python里面的函数分为类里面的方法和普通的函数，两者都是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Function</span><span class="params">(object)</span>:</span></span><br><span class="line">    . . .</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></span><br><span class="line">        <span class="string">"Simulate func_descr_get() in Objects/funcobject.c"</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> types.MethodType(self, obj)</span><br></pre></td></tr></table></figure>
<p>可以看到的是，首先无论是类方法还是普通函数，都是<strong>Function</strong>的一个对象，其次Function是一个描述器，这意味着，当作为类方法访问的时候，会去调用 <strong><strong>get</strong>方法</strong>，当用Class.Method的方式调用的时候，就直接返回函数自己，当使用Instance.Method的方式调用的时候，会返回<strong>types.MethodType(self, obj)</strong>，这个方法把函数绑定到类调用方的实例上，这样当该函数被调用的时候，会把<strong>obj</strong>作为第一个参数，也就是<strong>self</strong>作为参数穿进去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.f</span><br><span class="line">&lt;bound method Test.f of &lt;__main__.Test object at <span class="number">0x10e622be0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.f.__func__</span><br><span class="line">&lt;function Test.f at <span class="number">0x10e754ea0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.f.__self__</span><br><span class="line">&lt;__main__.Test object at <span class="number">0x10e622be0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.f.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">method</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Test</span>.<span class="title">f</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">function</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Test</span>.<span class="title">f</span>.<span class="title">__self__</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> <span class="params">(most recent call last)</span>:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'function'</span> object has no attribute <span class="string">'__self__'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Test.f.__func__</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'function'</span> object has no attribute <span class="string">'__func__'</span></span><br></pre></td></tr></table></figure>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>python是计数垃圾回收机制， <strong>weakref</strong>可以让我们引用一个对象，但是这个对象的计数并不会增加</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line">a = Test()</span><br><span class="line">c1 = sys.getrefcount(a) </span><br><span class="line">b =  weakfref.ref(a)</span><br><span class="line">c2  = sys.getrefcount(b)</span><br><span class="line">c1 == c2</span><br></pre></td></tr></table></figure>
<p>弱引用简单的来说，当它引用的对象存在时，则对象可用，当对象不存在时，就返回None，说明对象不存在。程序不会因为对象不在就报错。</p>
<h2 id="简化比较"><a href="#简化比较" class="headerlink" title="简化比较"></a>简化比较</h2><p>如果要让对象支持比较操作符，那么就要实现各种大于，小于，等于等内建方法，其实可以直接使用<strong>functools.total_ordering</strong>来简化操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> total_ordering</span><br><span class="line"><span class="meta">@total_ordering</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        self.val = v</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> other.val == self.val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.val &lt; other.val</span><br></pre></td></tr></table></figure>
<p><strong>total_ordering</strong>会自动生成其他的一些内建比较方法</p>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>Python中任何东西都是对象，包括数字，字符串，方法以及类， metaclass就是创建类对象的类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.__instance = <span class="literal">None</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, clsdict)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, clsname, bases, clsdict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__instance = super().__call__(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Creating Test'</span>)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br></pre></td></tr></table></figure>
<p>当Python解释器加载代码的时候，发现Test类的metaclass是Singleton，此时便依然 次调用Singleton的<strong>new</strong>和<strong>init</strong>方法来创建Test类对象（此时，创建的是Test类，而不是Test的实例，而当运行到 <strong>t = Test()</strong> 的时候，我们需要得到一个Test实例，那么就会调用Singleton的<strong>call</strong>方法去创建实例。</p>
<h2 id="关于prepare"><a href="#关于prepare" class="headerlink" title="关于prepare"></a>关于<strong>prepare</strong></h2><blockquote>
<p>Preparing the class namespace Once the appropriate metaclass has been identified, then the class namespace is prepared. If the metaclass has a <strong>prepare</strong> attribute, it is called as namespace = metaclass.<strong>prepare</strong>(name, bases, **kwds) (where the additional keyword arguments, if any, come from the class definition).<br>If the metaclass has no <strong>prepare</strong> attribute, then the class namespace is initialised as an empty ordered mapping.</p>
</blockquote>
<h2 id="可选参数的元类"><a href="#可选参数的元类" class="headerlink" title="可选参数的元类"></a>可选参数的元类</h2><p>在构建元类的时候，我们还可以传入额外的参数，不过这些参数同时需要在<strong>prepare</strong>,<strong>init</strong>和<strong>new</strong>中指定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases, *, debug=False, sync=False)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__prepare__(name, bases)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, ns, *, debug=False, sync=False)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, name, bases, ns)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, ns, *, debug=False, sync=False)</span>:</span></span><br><span class="line">        super().__init__(name, bases, ns)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(metaclass=Meta, debug=True, sync=False)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>锁是并发编程里最基本的primitive</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> lock, counter</span><br><span class="line">    lock.acjquire()</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    lock.release()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> lock, counter</span><br><span class="line">    lock.acquire()</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者直接用with</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> lock, counter</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        counter += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>python中的Event是用来同步通知线程的，主要用到<strong>wait</strong>和<strong>set</strong>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(event)</span>:</span></span><br><span class="line">    print(<span class="string">'start'</span>)</span><br><span class="line">    event.wait()</span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    threading.Thread(target=test, args=(event,))</span><br><span class="line">    print(<span class="string">'init'</span>)</span><br><span class="line">    event.set()</span><br><span class="line"><span class="comment">#当在event.set()调用之前，调用event.wait()的线程会一直等待，等到event.set()调用</span></span><br><span class="line"><span class="comment">#之后，该线程就会继续执行</span></span><br></pre></td></tr></table></figure>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>条件量也是一种线程协调的方式，往往可以用于条件性的生产者消费者模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">cond = threading.Condition()</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    cond.acquire()</span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n++</span><br><span class="line">        cond.notify()</span><br><span class="line">        cond.wait()</span><br><span class="line">    cond.release()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cond.acquire()</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            cond.notify()</span><br><span class="line">            cond.wait()</span><br><span class="line">        cond.release()</span><br></pre></td></tr></table></figure>
<p>当调用<strong>notify</strong>的时候，其他等待的<strong>wait</strong>会被唤醒。这里其实有两个锁，一个锁是上层的<strong>acquire</strong>，一个是<strong>wait</strong>的时候会创建一个锁，基本运行的过程是这样的：</p>
<ol>
<li>当producer中acquire执行的时候，会获得Condition的锁A</li>
<li>当notify执行的时候，会尝试从队列中获取锁并释放掉，此时没有任何锁</li>
<li>当wait执行的时候，会定义锁B，加入队列，并且acquire， 然后释放锁A，再次获取锁B，陷入等待（如果被notify之后，会再次获取锁A）</li>
<li>consumer端获取了锁A，当consumer去notify的时候，会从队列中拿到锁B，释放掉</li>
<li>当consumer调用wait的时候，会定义锁C，放入队列，并且acquire，然后释放锁A，再次获取C，陷入等待，而由于consumer已经释放了锁B和锁A，producer会从acquire锁B中醒来，然后再成功获取锁A。</li>
</ol>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器很简单</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">timer = threading.Timer(<span class="number">5</span>, <span class="keyword">lambda</span> : print(<span class="string">'x'</span>))</span><br><span class="line">timer.start()</span><br><span class="line">``` </span><br><span class="line"><span class="comment">## 信号量</span></span><br><span class="line">semaphore是量化控制线程的一种手段</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span>  threading</span><br><span class="line">semaphore = threading.Semaphore(<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    semaphore.acquire()</span><br><span class="line">    print(<span class="string">'hi'</span>)</span><br><span class="line">    semaphore.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    t = threading.Thread(target=test, args=())</span><br><span class="line">    t.start()</span><br><span class="line"><span class="comment">#同一时间只会有五个线程运行</span></span><br></pre></td></tr></table></figure>
<h2 id="Queue生产者消费者"><a href="#Queue生产者消费者" class="headerlink" title="Queue生产者消费者"></a>Queue生产者消费者</h2><p>由于Queue的put和get是线程安全的，所以可以使用Queue很方便的实现生产者消费者模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        q.put(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = q.get()</span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>我们可以使用协程来替代系统线程实现并发</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'count down for '</span>, n)</span><br><span class="line">        <span class="keyword">yield</span> </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span><span class="params">(n)</span>:</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; n:</span><br><span class="line">        print(<span class="string">'count up as '</span>, x)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._task_queue = deque()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_task</span><span class="params">(self, task)</span>:</span></span><br><span class="line">        self._task_queue.append(task)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> len(self._task_queue) &gt; <span class="number">0</span>:</span><br><span class="line">            task = self._task_queue.popleft()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                next(task)</span><br><span class="line">                self._task_queue.append(task)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">loop = EventLoop()</span><br><span class="line">loop.new_task(countdown(<span class="number">10</span>))</span><br><span class="line">loop.new_task(countdown(<span class="number">5</span>))</span><br><span class="line">loop.new_task(countup(<span class="number">15</span>))</span><br><span class="line">loop.new_task(countup(<span class="number">20</span>))</span><br><span class="line">loop.run()</span><br></pre></td></tr></table></figure>
<p>这里每一个任务都是一个协程，EventLoop就是调度器，这里的实现方式颇有点NodeJs的事件循环的意思</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/03/Boyer-Moore-%E7%AE%97%E6%B3%95/" rel="prev" title="Boyer-Moore 算法">
      <i class="fa fa-chevron-left"></i> Boyer-Moore 算法
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构和算法"><span class="nav-number">1.</span> <span class="nav-text">数据结构和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#序列分解"><span class="nav-number">1.1.</span> <span class="nav-text">序列分解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deque"><span class="nav-number">1.2.</span> <span class="nav-text">Deque</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heapq"><span class="nav-number">1.3.</span> <span class="nav-text">Heapq</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典"><span class="nav-number">1.4.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名切片"><span class="nav-number">1.5.</span> <span class="nav-text">命名切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#制表或者计数"><span class="nav-number">1.6.</span> <span class="nav-text">制表或者计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典和对象排序"><span class="nav-number">1.7.</span> <span class="nav-text">字典和对象排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据分组"><span class="nav-number">1.8.</span> <span class="nav-text">数据分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据过滤"><span class="nav-number">1.9.</span> <span class="nav-text">数据过滤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#namedtuple"><span class="nav-number">1.10.</span> <span class="nav-text">namedtuple</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并字典"><span class="nav-number">1.11.</span> <span class="nav-text">合并字典</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串处理"><span class="nav-number">2.</span> <span class="nav-text">字符串处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串分割匹配和搜索"><span class="nav-number">2.1.</span> <span class="nav-text">字符串分割匹配和搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串格式化"><span class="nav-number">2.2.</span> <span class="nav-text">字符串格式化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数字日期和时间"><span class="nav-number">3.</span> <span class="nav-text">数字日期和时间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数字的格式化"><span class="nav-number">3.1.</span> <span class="nav-text">数字的格式化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机选择"><span class="nav-number">3.2.</span> <span class="nav-text">随机选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日期和时间"><span class="nav-number">3.3.</span> <span class="nav-text">日期和时间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器与生成器"><span class="nav-number">4.</span> <span class="nav-text">迭代器与生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Yield"><span class="nav-number">4.1.</span> <span class="nav-text">Yield</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件与IO"><span class="nav-number">5.</span> <span class="nav-text">文件与IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件写入和打印"><span class="nav-number">5.1.</span> <span class="nav-text">文件写入和打印</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串IO"><span class="nav-number">5.2.</span> <span class="nav-text">字符串IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap"><span class="nav-number">5.3.</span> <span class="nav-text">mmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件路径"><span class="nav-number">5.4.</span> <span class="nav-text">文件路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#临时文件"><span class="nav-number">5.5.</span> <span class="nav-text">临时文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类与对象"><span class="nav-number">6.</span> <span class="nav-text">类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的显示"><span class="nav-number">6.1.</span> <span class="nav-text">对象的显示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上下文管理协议"><span class="nav-number">6.2.</span> <span class="nav-text">上下文管理协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节省内存的方式创建对象"><span class="nav-number">6.3.</span> <span class="nav-text">节省内存的方式创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#私有属性"><span class="nav-number">6.4.</span> <span class="nav-text">私有属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟属性和描述器"><span class="nav-number">6.5.</span> <span class="nav-text">延迟属性和描述器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-amp-amp-Function"><span class="nav-number">6.6.</span> <span class="nav-text">Method &amp;&amp; Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#弱引用"><span class="nav-number">6.7.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简化比较"><span class="nav-number">6.8.</span> <span class="nav-text">简化比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#元编程"><span class="nav-number">7.</span> <span class="nav-text">元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-number">7.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于prepare"><span class="nav-number">7.2.</span> <span class="nav-text">关于prepare</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选参数的元类"><span class="nav-number">7.3.</span> <span class="nav-text">可选参数的元类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发编程"><span class="nav-number">8.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock"><span class="nav-number">8.1.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event"><span class="nav-number">8.2.</span> <span class="nav-text">Event</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition"><span class="nav-number">8.3.</span> <span class="nav-text">Condition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时器"><span class="nav-number">8.4.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue生产者消费者"><span class="nav-number">8.5.</span> <span class="nav-text">Queue生产者消费者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程"><span class="nav-number">8.6.</span> <span class="nav-text">协程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ken-LiuL" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ken-LiuL" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pengkunliu@gmail.com" title="E-Mail → mailto:pengkunliu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/middlepeak" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;middlepeak" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/pengkunliu1" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;pengkunliu1" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">31k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">28 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: true,
      appId: 'kzsVBlzQJcu1PcAxdWhTMOb4-gzGzoHsz',
      appKey: 'NWQCGpUgg88uds6mq255jEyz',
      placeholder: "Comment here...",
      avatar: 'retro',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("kzsVBlzQJcu1PcAxdWhTMOb4-gzGzoHsz", "NWQCGpUgg88uds6mq255jEyz");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>




</body>
</html>
