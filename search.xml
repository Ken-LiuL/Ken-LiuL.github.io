<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>链表是否有环</title>
    <url>/2020/04/22/%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
    <content><![CDATA[<p>判断单链表是否有环，以及环的长度和环开始的地方是常见的面试题，如leetcode上的<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">判断是否有环</a>和<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">给出环的起点</a>，基本上这种问题的解决思路就是快慢指针，这里我们介绍下Brent’s Cycle Detection Algorithm， 思路其实就是快慢指针，但是略有不同。</p>
<a id="more"></a>
<h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>快慢指针的思路其实就是，快指针每次往前移动两次而慢指针每次移动一次，那么如果这个单链表存在环路的话，迟早快指针会和慢指针相遇，否则就不存在环路。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span>  || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Brent’s-Cycle-Detection-Algorithm"><a href="#Brent’s-Cycle-Detection-Algorithm" class="headerlink" title="Brent’s Cycle Detection Algorithm"></a>Brent’s Cycle Detection Algorithm</h1><p>Brent算法虽然也是用快慢两个指针来检测环，但是区别是快指针每次移动2^N次之后才去移动慢指针，比如，一开始快指针移动2步，然后去更新慢指针，然后4步、8步直到找到环路或者发现并不存在环路。Brent’s算法有两个优势，一个是算法常数上来说会快于传统的快慢指针（两者都是O(N))，另外一个是，当要求给出环路的长度的时候，Brent’s的算法在检测到环路的同时，就已经得到来环路的长度了，不需要额外的计算，相当于了一个side effect。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    steps_taken, step_limit := <span class="number">0</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        steps_taken++</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> steps_taken == step_limit &#123;</span><br><span class="line">            steps_taken = <span class="number">0</span></span><br><span class="line">            step_limit *= <span class="number">2</span></span><br><span class="line">            slow = fast</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当算法结束的时候，steps_taken就是环的长度，这里面的逻辑是这样的，我们需要快速的把slow和fast两个指针快速的迭代进入环，只要当slow和fast两个指针已经进入环路中了，那么此时只要移动快指针N步，当N大于等于环路的长度的时候，那么自然两个指针会相遇，记录快指针移动了多少步的变量steps_taken就是环路的长度了。</p>
<h1 id="环路的起点"><a href="#环路的起点" class="headerlink" title="环路的起点"></a>环路的起点</h1><p>如果我们同时需要直到环路从哪个node开始，如<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">leetcode这道题</a>，还需要一个些额外的逻辑来处理。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fast, slow = head, head</span><br><span class="line"><span class="keyword">for</span> steps_taken &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fast = fast.Next</span><br><span class="line">    steps_taken--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">    fast = fast.Next</span><br><span class="line">    slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<p>上面这段代码可以帮助我们找到作为环起点的node，这里的逻辑初看可能有点不是很直观，但是有他内在的逻辑。我们假设整个单链表的长度（节点数）为N， 环的长度为L，环的起点的index为I 那么第一个for循环跑完之后，fast指针位于L的位置， 由于<code>N = L + I</code>，那么快指针再走<strong>I</strong>步就到了loop的起点，此时慢指针处于0的位置，慢指针走<strong>I</strong>步也到了loop的起点， 所以在第二个loop里，我们让快慢指针同时往前走，如果他们相遇，就代表他们同步到达了loop的起点。</p>
]]></content>
  </entry>
  <entry>
    <title>二叉树先序中序后序的非递归实现</title>
    <url>/2020/01/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>上一篇中我们讲到对于递归形式的实现，无论是先序、中序还是后序，代码都是统一形式，区别无非就是处理节点的函数位置不同，那么对于非递归的形式，是否也有统一的实现方式呢？</p>
<p>答案是肯定的，只不过如果要达到这种统一，需要引入一些额外的变量和代码进来。</p>
<a id="more"></a>
<h1 id="先序和中序遍历"><a href="#先序和中序遍历" class="headerlink" title="先序和中序遍历"></a>先序和中序遍历</h1><p>对于非递归的遍历方式而言，先序和中序是很容易找到统一的代码形式的</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tranverse</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	cur := root</span><br><span class="line">	s := newStack()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> || !s.isEmpty() &#123;</span><br><span class="line">            <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">                s.push(cur)</span><br><span class="line">                <span class="comment">//先序</span></span><br><span class="line">                <span class="comment">//handle(cur.Val)</span></span><br><span class="line">                cur = cur.Left</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment">//中序</span></span><br><span class="line">            <span class="comment">//handle(cur.Val)</span></span><br><span class="line">            cur = cur.Right</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码形式来看是统一的，先把节点放到stack里面， 然后当当前的节点为nil的时候，我们从stack里面把节点pop出来，唯一的区别是处理节点的函数放置位置会有所不同。</p>
<p><img src="/images/tree/simple-tree-nodes.png" alt=""><br>以上图为例子，stack中元素的变化为:</p>
<ol>
<li>[10] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//push 10</li>
<li>[10, 5] &nbsp;&nbsp;&nbsp;//push 5</li>
<li>[10, 5, 1] //push完1之后，cur == nil,会跳出循环</li>
<li>[10, 5]  &nbsp;&nbsp;&nbsp;//pop出1, 接下来cur设为1.right，也就是nil</li>
<li>[10] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //此时cur == nil, 会跳出循环, pop出5, cur为5.right, 也就是6</li>
<li>[10, 6]  &nbsp;&nbsp;&nbsp;&nbsp;//push6之后， cur == nil, 会跳出循环</li>
<li>[10] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//pop出6，接下来cur设为6.right，也就是nil</li>
<li>[] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//pop出10，接下来cur设为10.right, 也就是19</li>
<li>[19] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//push 19</li>
<li>[19, 17] &nbsp; //push 17之后，cur == nil，然后重复上面的步骤直到stack为空</li>
</ol>
<p>从观察stack， 我们可以看出来，只要处理元素的函数放在pop之后，那么就是中序，放在循环push里面就是先序。 但是用这个代码框架，我们没办法实现后序遍历，其核心原因是没有办法保存整个栈状态以及区分放到stack里面的元素是左节点还是右节点， 所以无论把处理函数放在哪个位置，都无法兼容后序遍历。</p>
<h1 id="统一的形式"><a href="#统一的形式" class="headerlink" title="统一的形式"></a>统一的形式</h1><p>如果我们可以有种办法来区分处理的是左节点还是右节点，那么就可以做到兼容后序遍历。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    cur := root</span><br><span class="line">    s := newStack()</span><br><span class="line">    pre := cur</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> || !s.isEmpty() &#123;</span><br><span class="line">        <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">//先序遍历</span></span><br><span class="line">            <span class="comment">//handle(cur.Val)</span></span><br><span class="line">            s.push(cur)</span><br><span class="line">            cur = cur.Left</span><br><span class="line">        &#125;                               </span><br><span class="line">        cur  = s.seek()  </span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">            <span class="comment">//  handle(cur.Val)</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        cur = cur.Right </span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">            pre = s.pop()</span><br><span class="line">            <span class="comment">//后序遍历</span></span><br><span class="line">            <span class="comment">//handle(pre.Val)</span></span><br><span class="line">            cur = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们添加了一个pre变量， pre指向的永远都是上一次pop出来的元素，然后核心的部分其实在这段代码</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">	pre = s.pop()   </span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="comment">//handle(pre.Val)</span></span><br><span class="line">	cur = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们并没有马上pop， 而是选择性pop，并用pre变量记录下上次pop的元素，用这样的方式来改变节点访问的顺序， 在这种遍历方式下，父节点会被访问两次, 第一次作为临时节点，我们拿到右节点，所以<code>cur = s.seek()</code> , 而不是pop， 然后我们通过 <code>cur = cur.Right</code>拿到右节点push到stack里面去进行处理，当进行到叶子节点也就是<code>cur == nil</code>判断的时候， 我们把节点pop出来，并且<code>pre = s.pop; cur = nil</code>，此时会再次去访问一次父节点<code>cur = s.seek()</code>，由于<code>cur=cur.Right; pre == cur</code>， 所以我们会把父节点此时pop出去。这里两次访问父节点， 其实模拟了递归方式里保存栈空间的操作，把父节点的信息保存下来了。</p>
<p>还是以上图为例， 当我们第一次跳出for循环之后，栈的变换为：</p>
<ol>
<li><p>[10, 5, 1]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为1 </span></span><br><span class="line">  <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为nil</span></span><br><span class="line"> <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">     pre = s.pop()  <span class="comment">//pre为 1 </span></span><br><span class="line">     <span class="comment">//后序遍历</span></span><br><span class="line">     <span class="comment">//handle(pre.Val)</span></span><br><span class="line">     cur = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>[10, 5]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为5, 第一次访问父节点</span></span><br><span class="line"> <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为6, pre为1</span></span><br><span class="line"> <span class="comment">//接下来会把cur push到stack里面去并跳出循环</span></span><br></pre></td></tr></table></figure></li>
<li><p>[10, 5, 6]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为6</span></span><br><span class="line"> <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为nil</span></span><br><span class="line"> <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">     pre = s.pop()  <span class="comment">//pre为 6 </span></span><br><span class="line">     <span class="comment">//后序遍历</span></span><br><span class="line">     <span class="comment">//handle(pre.Val)</span></span><br><span class="line">     cur = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>[10, 5]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为5, 第二次访问父节点</span></span><br><span class="line"> <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为6, pre 也为6</span></span><br><span class="line"> <span class="comment">//此时cur == pre, 代表右节点已经访问过了, 我们需要pop</span></span><br><span class="line"> <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">     pre = s.pop()  <span class="comment">//pre为 5 </span></span><br><span class="line">     <span class="comment">//后序遍历</span></span><br><span class="line">     <span class="comment">//handle(pre.Val)</span></span><br><span class="line">     cur = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>从上面的步骤我们可以看出来我们的代码清楚分离了各个节点处理的阶段，如果放在for循环里就是先序，如果放在seek后就是中序，如果放在pop后就是后序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的核心就是只有当前节点下面的子节点都访问过之后，我们才去pop，不然就用seek来获得节点和其子节点，这样该节点的信息依然保留在stack里面，其次，用额外的变量去记录上次访问过的节点，用来识别是否右子树已经访问过了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的先序中序后序递归实现</title>
    <url>/2020/01/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>二叉树常见的遍历方式有三种（除去Level Traversal，也就是广度优先遍历），分别为先序遍历，中序遍历和后序遍历，而实现方式既有递归的实现方式也有非递归的实现方式。当然，递归的实现方式是最简单的。</p>
<a id="more"></a>
<h1 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h1><p>二叉树的三种遍历方式为：</p>
<ul>
<li>先序遍历：根-&gt;左-&gt;右</li>
<li>中序遍历：左-&gt;根-&gt;右</li>
<li>后序遍历：左-&gt;右-&gt;根</li>
</ul>
<p><img src="/images/tree/simple-tree-nodes.png" alt=""></p>
<p>对于以上这样一个简单的二叉树，如果我们以不同的遍历方式输出节点的值，那么产生的值的顺序为：</p>
<ul>
<li>先序遍历：10 5 1 6 19 17 21</li>
<li>中序遍历：1 5 6 10 17 19 21</li>
<li>后序遍历：1 6 5 17 21 19 10</li>
</ul>
<p>不同的遍历方式输出的节点值的顺序不同</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>我们先来看一下一个标准的递归访问树节点的实现方式</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root ==  <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	traverse(root.Left, arr)</span><br><span class="line">	traverse(root.Right, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">treeTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> traverse(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很标准简洁的递归访问树节点的方式，具体的访问顺序如下图<br><img src="/images/tree/recursive-tree-traversal.png" alt=""></p>
<p>这里仅仅画出了从root到左子树的访问和返回顺序，右子树大致相同。箭头上黑色的数字代表进入下一层递归，比如当root代表值为10的节点时候，图中箭头上1代表</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">traverse(root.Left, arr)</span><br></pre></td></tr></table></figure>
<p>而箭头上红色的数字代表该层函数结束，返回上一层，比如当root代表值为1的节点的时候，图中箭头上的红色4代表</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> root ==  <span class="literal">nil</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>返回到上一层调用者的步骤。<br>我们通过观察可以发现，我们的递归函数以固定的顺序<strong>访问</strong>树中的每一个节点，但是三种不同的遍历方式要求<strong>处理/输出</strong>的节点的顺序却是不一样，那么如何能用这个统一的递归访问方式来得到不同顺序的处理结果呢？关键点就在处理函数（对节点进行处理的函数，最简单的就是将节点值输出到标准输出流println）的放置位置。</p>
<h1 id="统一的实现"><a href="#统一的实现" class="headerlink" title="统一的实现"></a>统一的实现</h1><h2 id="先序遍历：根-gt-左-gt-右"><a href="#先序遍历：根-gt-左-gt-右" class="headerlink" title="先序遍历：根-&gt;左-&gt;右"></a>先序遍历：根-&gt;左-&gt;右</h2><p>由于先序遍历是根-&gt;左-&gt;右，那么我们应该把函数放在访问左右节点之前，也就是</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">handle(root.Value)</span><br><span class="line">traverse(root.Left, arr)</span><br><span class="line">traverse(root.Right, arr)</span><br></pre></td></tr></table></figure>
<p>对应的处理访问次序图为<br><img src="/images/tree/pre-order-recursive-traversal.png" alt=""><br>显而易见，我们以先序(10 5 1 6)的方式处理节点的值。</p>
<h2 id="中序遍历：左-gt-根-gt-右"><a href="#中序遍历：左-gt-根-gt-右" class="headerlink" title="中序遍历：左-&gt;根-&gt;右"></a>中序遍历：左-&gt;根-&gt;右</h2><p>由于中序遍历是左-&gt;根-&gt;右，那么我们应该把函数放在访问左节点之前和右节点之前，也就是</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">traverse(root.Left, arr)</span><br><span class="line">handle(root.Value)</span><br><span class="line">traverse(root.Right, arr)</span><br></pre></td></tr></table></figure>

<p>对应的处理访问次序图为<br><img src="/images/tree/in-order-recursive-traversal.png" alt=""><br>按箭头上代表步骤的数字来依次查看，确实是按中序遍历（1 5 6 10）来处理节点的值。</p>
<h2 id="后序遍历：左-gt-右-gt-根"><a href="#后序遍历：左-gt-右-gt-根" class="headerlink" title="后序遍历：左-&gt;右-&gt;根"></a>后序遍历：左-&gt;右-&gt;根</h2><p>由于后序遍历是左-&gt;右-&gt;根，那么我们应该把函数放在访问左节点和右节点之后，也就是</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">traverse(root.Left, arr)</span><br><span class="line">traverse(root.Right, arr) </span><br><span class="line">handle(root.Value)</span><br></pre></td></tr></table></figure>

<p>对应的处理访问次序图为<br><img src="/images/tree/post-order-recursive-traversal.png" alt=""><br>按箭头上代表步骤的数字来依次查看，确实是按后序遍历（1 6 5）来处理节点的值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然二叉树的遍历方式有三种，但是实现起来其实代码是几乎一摸一样的， 我们以固定的顺序去拜访这些节点，区别只是处理节点的函数摆放的位置不同，先序是还未拜访左右子节点之前就调用处理函数，中序是拜访完左子节点就调用，后序是拜访完左右子节点再调用处理函数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
</search>
