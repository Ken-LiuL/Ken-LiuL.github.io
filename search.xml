<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Boyer-Moore 算法</title>
    <url>/2020/05/03/Boyer-Moore-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>今天在做Leetcode上的<a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">这道找到数组中的majority element</a>题目时候，发现了一个有意思的算法，Boyer-Moore算法，可以在不借助哈希表和排序的情况下，以O(n)的时间复杂度来解决这个问题。</p>
<a id="more"></a>

<h1 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>如果我们首先将数组进行排序，然后直接返回中间的数，那么这个数字肯定是majority element。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简洁， 时间复杂度为O(NlogN)， 空间复杂度为常数项。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>用哈希表记录下每个数字出现的次数，然后当某个数字出现的次数超过1/2的时候，就可以将其返回。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">     <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">         dict[n]++</span><br><span class="line">         <span class="keyword">if</span> dict[n] &gt; <span class="built_in">len</span>(nums) /<span class="number">2</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> n</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(N)，但是空间复杂度为O(N)，并且涉及到哈希表的读取写入和扩容，实际时间并不快。</p>
<h1 id="Boyer-Moore算法"><a href="#Boyer-Moore算法" class="headerlink" title="Boyer-Moore算法"></a>Boyer-Moore算法</h1><p>该算法可以用O(1)的空间复杂度和O(N)的时间复杂度来解决此类问题，最早在<a href="http://www.cs.rug.nl/~wim/pub/whh348.pdf" target="_blank" rel="noopener">这篇论文</a>被提出。我们先看看代码 </p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count, res := <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _,  n := <span class="keyword">range</span> nums[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            res = n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n == res &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以假设majority element为s， 那么数组可以视为[a…s…c…s…b..d…s…s]， 也就是各个s元素之间穿插着其他的元素，由于s的数量超过所有的元素加起来的数量，那么至少有两个s元素连在一起，那么上述的count最终肯定为正数，并且res就为我们要找的元素。<br>假设nums为</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<ol>
<li>res为5， count++ 一直到2</li>
<li>遇到0，count– 到1</li>
<li>遇到0， count– 到0</li>
<li>res为0， count++ 为1</li>
<li>遇到5， count– 到0</li>
<li>res为5， count++ 为1</li>
<li>遇到0， count– 到0</li>
<li>res为0， count++ 为1</li>
<li>遇到0， count++ 到2</li>
<li>遇到5， count– 为1</li>
<li>返回5作为majority element</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Boyer-Moore算法虽然并不直观，但是有良好的时间复杂度和空间复杂度，并且实现的代码非常简洁干净，多思考算法所蕴含的逻辑有助于掌握该算法。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划问题的思路和技巧</title>
    <url>/2020/04/24/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%A7%E9%83%A8%E5%88%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>动态规划是算法中最常见的一类问题之一，其解题思路常常为，将大问题分解为小问题，并且建立起通过解决小问题到解决大问题的对应关系来得到最终的答案，一旦找了分解问题和合并小问题答案的方程，问题本身就迎刃而解。然而，对于具体实现来说，从找到对应关系到最优的实现方式之间往往有着一些小技巧，这篇文章主要展开讲讲如何用一套思维模式和技巧来解决优化大部分动态规划的问题。</p>
<a id="more"></a>
<p>我们以leetcode上这道<a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">easy的动态规划题</a>为例子来层层剖析如何切入这种类型的题目。</p>
<h1 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h1><p>由于强盗不能抢相邻的两间房子，那么对于任意一间房子i而言，强盗要么</p>
<ol>
<li>抢当前的，然后跳过i+1间房子</li>
<li>不抢当前的房子，然后抢i+1间房子</li>
</ol>
<p>也就是说，对于任意一间房子i来说，强盗都有两个选择，并且每次选择都会影响后面的选择和结果，这是动态规划题目一个非常典型的特征，每次决策都对下一次决策参加影响，对最后的结果起作用。那对于这个抢房子的问题来说，我们已经将这个大问题分解成了小问题，让dp(i)代表，当强盗从第i个房子开始抢， 他能得到的最大收益，那么存在下面等式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp(i) &#x3D;  max(dp(i+2)+house_value[i], dp(i+1))</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>当我们找到了问题分解之后的对应关系后，最简单的实现方式就是递归了</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="keyword">int</span> , i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="built_in">len</span>(nums) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max(robbery current, skip current)</span></span><br><span class="line">    <span class="keyword">return</span> max(helper(nums, i+<span class="number">2</span>)+nums[i], helper(nums, i+<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="memorization"><a href="#memorization" class="headerlink" title="memorization"></a>memorization</h1><p>递归是最简单的实现方式，不过上述的实现方式浪费了很多时间在重复计算上面，动态规划问题可以通过memorization的方式来实现优化。memorization就是用字典或者数组来记住计算过的结果来避免重复计算、提高速度，比较典型的应用就是斐波那契数列。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="keyword">int</span> , i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="built_in">len</span>(nums)<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dp[i] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max(robbery current, skip current)</span></span><br><span class="line">    val := max(helper(nums, i+<span class="number">2</span>)+nums[i], helper(nums, i+<span class="number">1</span>))</span><br><span class="line">    dp[i] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>递归往往可以退化为循环的实现方式，虽然时间复杂度是一样的，但是循环避免了大量调用栈的创建和函数调用的开销，所以往往会快一些，而且在动态规划问题中来看，循环的实现方式更简介，因为动态规划问题的本质就是在前后状态有依赖的前提下来进行状态的推导。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        dp[i] = max(dp[i+<span class="number">2</span>]+nums[i], dp[i+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们推导的公式是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp(i) &#x3D;  max(dp(i+2)+house_value[i], dp(i+1))</span><br></pre></td></tr></table></figure>
<p>所以，在for循环里面，我们是从数组的末尾开始到index为0为止，这也叫top-down。另外一种是down-top的方式，假如dp[i]代表的是当强盗当抢到第i个房子时， 他已经得到的最大收益，那么存在下面的等式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp(i) &#x3D; max(dp(i - 2) + house_value[i], dp(i - 1))</span><br></pre></td></tr></table></figure>
<p>本质上两种方式是一样的，只是建模的思维不同而已，具体到代码实现上会体现为循环推导的方向不一样，down-top则是从头开始，而不是从末尾。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(nums)+<span class="number">2</span>; i++ &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-2</span>]+nums[i<span class="number">-2</span>], dp[i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(nums) +  <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="减少空间复杂度"><a href="#减少空间复杂度" class="headerlink" title="减少空间复杂度"></a>减少空间复杂度</h1><p>动态规划问题往往会用一维数组或者矩阵来保存状态和进行状态推导，比如强盗问题中，我们用一维数组dp来实现memorization，但是其实仔细分析我们会发现，我们只需要两个变量就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">current &#x3D;  max(prev2 + house_value[i], prev1)</span><br></pre></td></tr></table></figure>
<p>由于每次我们都只依赖两个状态，分别代表dp[i-2] (或者dp[i+2) 和dp[i-1] （或者dp[i+1])，那么我们就可以只用两个变量来优化我们的空间复杂度， 然后每次循环让</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">prev2 = prev1</span><br><span class="line">prev1 = current</span><br></pre></td></tr></table></figure>

<p>迭代去更新这两个变量的值即可。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    prev1, prev2, curr := <span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        curr = max(prev2 + n, prev1)</span><br><span class="line">        prev1, prev2  = curr, prev1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，经过以上的步骤，我们最终可以以非常简洁的代码、低空间复杂度和时间复杂度来解决一个动态规划的问题。其实解决动态规划问题的关键就是找到问题分解之后的推导关系，剩下的实现部分就可以像上面一样一步步优化。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems" target="_blank" rel="noopener">https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>链表是否有环</title>
    <url>/2020/04/22/%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
    <content><![CDATA[<p>判断单链表是否有环，以及环的长度和环开始的地方是常见的面试题，如leetcode上的<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">判断是否有环</a>和<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">给出环的起点</a>，基本上这种问题的解决思路就是快慢指针，这里我们介绍下Brent’s Cycle Detection Algorithm， 思路其实就是快慢指针，但是略有不同。</p>
<a id="more"></a>
<h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>快慢指针的思路其实就是，快指针每次往前移动两次而慢指针每次移动一次，那么如果这个单链表存在环路的话，迟早快指针会和慢指针相遇，否则就不存在环路。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span>  || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Brent’s-Cycle-Detection-Algorithm"><a href="#Brent’s-Cycle-Detection-Algorithm" class="headerlink" title="Brent’s Cycle Detection Algorithm"></a>Brent’s Cycle Detection Algorithm</h1><p>Brent算法虽然也是用快慢两个指针来检测环，但是区别是快指针每次移动2^N次之后才去移动慢指针，比如，一开始快指针移动2步，然后去更新慢指针，然后4步、8步直到找到环路或者发现并不存在环路。Brent’s算法有两个优势，一个是算法常数上来说会快于传统的快慢指针（两者都是O(N))，另外一个是，当要求给出环路的长度的时候，Brent’s的算法在检测到环路的同时，就已经得到环路的长度了，不需要额外的计算，相当于了一个side effect。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    steps_taken, step_limit := <span class="number">0</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        steps_taken++</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> steps_taken == step_limit &#123;</span><br><span class="line">            steps_taken = <span class="number">0</span></span><br><span class="line">            step_limit *= <span class="number">2</span></span><br><span class="line">            slow = fast</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当算法结束的时候，steps_taken就是环的长度，这里面的逻辑是这样的，我们需要快速把slow和fast两个指针迭代进入环，只要slow和fast两个指针进入环中，此时只要移动快指针N步，当N大于等于环路的长度的时候，那么自然两个指针会相遇，记录快指针移动了多少步的变量steps_taken就是环路的长度了。</p>
<h1 id="环路的起点"><a href="#环路的起点" class="headerlink" title="环路的起点"></a>环路的起点</h1><p>如果我们同时需要直到环路从哪个node开始，如<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">leetcode中的这道题</a>，还需要一个些额外的逻辑来处理。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fast, slow = head, head</span><br><span class="line"><span class="keyword">for</span> steps_taken &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fast = fast.Next</span><br><span class="line">    steps_taken--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">    fast = fast.Next</span><br><span class="line">    slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<p>上面这段代码可以帮助我们找到作为环起点的node，这里初看可能有点不是很直观，但是内在的逻辑很简单。我们假设整个单链表的长度（节点数）为N， 环的长度为L，环的起点的index为I 那么第一个for循环跑完之后，fast指针位于L的位置， 由于<code>N = L + I</code>，那么快指针再走<strong>I</strong>步就到了loop的起点，此时慢指针处于0的位置，慢指针走<strong>I</strong>步也到了loop的起点， 所以在第二个loop里，我们让快慢指针同时往前走，如果他们相遇，就代表他们同步到达了loop的起点。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="http://www.siafoo.net/algorithm/11" target="_blank" rel="noopener">http://www.siafoo.net/algorithm/11</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树先序中序后序的非递归实现</title>
    <url>/2020/01/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>上一篇中我们讲到对于递归形式的实现，无论是先序、中序还是后序，代码都是统一形式，区别无非就是处理节点的函数位置不同，那么对于非递归的形式，是否也有统一的实现方式呢？</p>
<p>答案是肯定的，只不过如果要达到这种统一，需要引入一些额外的变量和代码进来。</p>
<a id="more"></a>
<h1 id="先序和中序遍历"><a href="#先序和中序遍历" class="headerlink" title="先序和中序遍历"></a>先序和中序遍历</h1><p>对于非递归的遍历方式而言，先序和中序是很容易找到统一的代码形式的</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tranverse</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	cur := root</span><br><span class="line">	s := newStack()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> || !s.isEmpty() &#123;</span><br><span class="line">            <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">                s.push(cur)</span><br><span class="line">                <span class="comment">//先序</span></span><br><span class="line">                <span class="comment">//handle(cur.Val)</span></span><br><span class="line">                cur = cur.Left</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment">//中序</span></span><br><span class="line">            <span class="comment">//handle(cur.Val)</span></span><br><span class="line">            cur = cur.Right</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码形式来看是统一的，先把节点放到stack里面， 然后当当前的节点为nil的时候，我们从stack里面把节点pop出来，唯一的区别是处理节点的函数放置位置会有所不同。</p>
<p><img src="/images/tree/simple-tree-nodes.png" alt=""><br>以上图为例子，stack中元素的变化为:</p>
<ol>
<li>[10] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//push 10</li>
<li>[10, 5] &nbsp;&nbsp;&nbsp;//push 5</li>
<li>[10, 5, 1] //push完1之后，cur == nil,会跳出循环</li>
<li>[10, 5]  &nbsp;&nbsp;&nbsp;//pop出1, 接下来cur设为1.right，也就是nil</li>
<li>[10] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //此时cur == nil, 会跳出循环, pop出5, cur为5.right, 也就是6</li>
<li>[10, 6]  &nbsp;&nbsp;&nbsp;&nbsp;//push6之后， cur == nil, 会跳出循环</li>
<li>[10] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//pop出6，接下来cur设为6.right，也就是nil</li>
<li>[] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//pop出10，接下来cur设为10.right, 也就是19</li>
<li>[19] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//push 19</li>
<li>[19, 17] &nbsp; //push 17之后，cur == nil，然后重复上面的步骤直到stack为空</li>
</ol>
<p>从观察stack， 我们可以看出来，只要处理元素的函数放在pop之后，那么就是中序，放在循环push里面就是先序。 但是用这个代码框架，我们没办法实现后序遍历，其核心原因是没有办法保存整个栈状态以及区分放到stack里面的元素是左节点还是右节点， 所以无论把处理函数放在哪个位置，都无法兼容后序遍历。</p>
<h1 id="统一的形式"><a href="#统一的形式" class="headerlink" title="统一的形式"></a>统一的形式</h1><p>如果我们可以有种办法来区分处理的是左节点还是右节点，那么就可以做到兼容后序遍历。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    cur := root</span><br><span class="line">    s := newStack()</span><br><span class="line">    pre := cur</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> || !s.isEmpty() &#123;</span><br><span class="line">        <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">//先序遍历</span></span><br><span class="line">            <span class="comment">//handle(cur.Val)</span></span><br><span class="line">            s.push(cur)</span><br><span class="line">            cur = cur.Left</span><br><span class="line">        &#125;                               </span><br><span class="line">        cur  = s.seek()  </span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">            <span class="comment">//  handle(cur.Val)</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        cur = cur.Right </span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">            pre = s.pop()</span><br><span class="line">            <span class="comment">//后序遍历</span></span><br><span class="line">            <span class="comment">//handle(pre.Val)</span></span><br><span class="line">            cur = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们添加了一个pre变量， pre指向的永远都是上一次pop出来的元素，然后核心的部分其实在这段代码</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">	pre = s.pop()   </span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="comment">//handle(pre.Val)</span></span><br><span class="line">	cur = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们并没有马上pop， 而是选择性pop，并用pre变量记录下上次pop的元素，用这样的方式来改变节点访问的顺序， 在这种遍历方式下，父节点会被访问两次, 第一次作为临时节点，我们拿到右节点，所以<code>cur = s.seek()</code> , 而不是pop， 然后我们通过 <code>cur = cur.Right</code>拿到右节点push到stack里面去进行处理，当进行到叶子节点也就是<code>cur == nil</code>判断的时候， 我们把节点pop出来，并且<code>pre = s.pop; cur = nil</code>，此时会再次去访问一次父节点<code>cur = s.seek()</code>，由于<code>cur=cur.Right; pre == cur</code>， 所以我们会把父节点此时pop出去。这里两次访问父节点， 其实模拟了递归方式里保存栈空间的操作，把父节点的信息保存下来了。</p>
<p>还是以上图为例， 当我们第一次跳出for循环之后，栈的变换为：</p>
<ol>
<li><p>[10, 5, 1]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为1 </span></span><br><span class="line">  <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为nil</span></span><br><span class="line"> <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">     pre = s.pop()  <span class="comment">//pre为 1 </span></span><br><span class="line">     <span class="comment">//后序遍历</span></span><br><span class="line">     <span class="comment">//handle(pre.Val)</span></span><br><span class="line">     cur = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>[10, 5]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为5, 第一次访问父节点</span></span><br><span class="line"> <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为6, pre为1</span></span><br><span class="line"> <span class="comment">//接下来会把cur push到stack里面去并跳出循环</span></span><br></pre></td></tr></table></figure></li>
<li><p>[10, 5, 6]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为6</span></span><br><span class="line"> <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为nil</span></span><br><span class="line"> <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">     pre = s.pop()  <span class="comment">//pre为 6 </span></span><br><span class="line">     <span class="comment">//后序遍历</span></span><br><span class="line">     <span class="comment">//handle(pre.Val)</span></span><br><span class="line">     cur = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>[10, 5]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为5, 第二次访问父节点</span></span><br><span class="line"> <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为6, pre 也为6</span></span><br><span class="line"> <span class="comment">//此时cur == pre, 代表右节点已经访问过了, 我们需要pop</span></span><br><span class="line"> <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">     pre = s.pop()  <span class="comment">//pre为 5 </span></span><br><span class="line">     <span class="comment">//后序遍历</span></span><br><span class="line">     <span class="comment">//handle(pre.Val)</span></span><br><span class="line">     cur = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>从上面的步骤我们可以看出来我们的代码清楚分离了各个节点处理的阶段，如果放在for循环里就是先序，如果放在seek后就是中序，如果放在pop后就是后序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的核心就是只有当前节点下面的子节点都访问过之后，我们才去pop，不然就用seek来获得节点和其子节点，这样该节点的信息依然保留在stack里面，其次，用额外的变量去记录上次访问过的节点，用来识别是否右子树已经访问过了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的先序中序后序递归实现</title>
    <url>/2020/01/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>二叉树常见的遍历方式有三种（除去Level Traversal，也就是广度优先遍历），分别为先序遍历，中序遍历和后序遍历，而实现方式既有递归的实现方式也有非递归的实现方式。当然，递归的实现方式是最简单的。</p>
<a id="more"></a>
<h1 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h1><p>二叉树的三种遍历方式为：</p>
<ul>
<li>先序遍历：根-&gt;左-&gt;右</li>
<li>中序遍历：左-&gt;根-&gt;右</li>
<li>后序遍历：左-&gt;右-&gt;根</li>
</ul>
<p><img src="/images/tree/simple-tree-nodes.png" alt=""></p>
<p>对于以上这样一个简单的二叉树，如果我们以不同的遍历方式输出节点的值，那么产生的值的顺序为：</p>
<ul>
<li>先序遍历：10 5 1 6 19 17 21</li>
<li>中序遍历：1 5 6 10 17 19 21</li>
<li>后序遍历：1 6 5 17 21 19 10</li>
</ul>
<p>不同的遍历方式输出的节点值的顺序不同</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>我们先来看一下一个标准的递归访问树节点的实现方式</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root ==  <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	traverse(root.Left, arr)</span><br><span class="line">	traverse(root.Right, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">treeTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> traverse(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很标准简洁的递归访问树节点的方式，具体的访问顺序如下图<br><img src="/images/tree/recursive-tree-traversal.png" alt=""></p>
<p>这里仅仅画出了从root到左子树的访问和返回顺序，右子树大致相同。箭头上黑色的数字代表进入下一层递归，比如当root代表值为10的节点时候，图中箭头上1代表</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">traverse(root.Left, arr)</span><br></pre></td></tr></table></figure>
<p>而箭头上红色的数字代表该层函数结束，返回上一层，比如当root代表值为1的节点的时候，图中箭头上的红色4代表</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> root ==  <span class="literal">nil</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>返回到上一层调用者的步骤。<br>我们通过观察可以发现，我们的递归函数以固定的顺序<strong>访问</strong>树中的每一个节点，但是三种不同的遍历方式要求<strong>处理/输出</strong>的节点的顺序却是不一样，那么如何能用这个统一的递归访问方式来得到不同顺序的处理结果呢？关键点就在处理函数（对节点进行处理的函数，最简单的就是将节点值输出到标准输出流println）的放置位置。</p>
<h1 id="统一的实现"><a href="#统一的实现" class="headerlink" title="统一的实现"></a>统一的实现</h1><h2 id="先序遍历：根-gt-左-gt-右"><a href="#先序遍历：根-gt-左-gt-右" class="headerlink" title="先序遍历：根-&gt;左-&gt;右"></a>先序遍历：根-&gt;左-&gt;右</h2><p>由于先序遍历是根-&gt;左-&gt;右，那么我们应该把函数放在访问左右节点之前，也就是</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">handle(root.Value)</span><br><span class="line">traverse(root.Left, arr)</span><br><span class="line">traverse(root.Right, arr)</span><br></pre></td></tr></table></figure>
<p>对应的处理访问次序图为<br><img src="/images/tree/pre-order-recursive-traversal.png" alt=""><br>显而易见，我们以先序(10 5 1 6)的方式处理节点的值。</p>
<h2 id="中序遍历：左-gt-根-gt-右"><a href="#中序遍历：左-gt-根-gt-右" class="headerlink" title="中序遍历：左-&gt;根-&gt;右"></a>中序遍历：左-&gt;根-&gt;右</h2><p>由于中序遍历是左-&gt;根-&gt;右，那么我们应该把函数放在访问左节点之前和右节点之前，也就是</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">traverse(root.Left, arr)</span><br><span class="line">handle(root.Value)</span><br><span class="line">traverse(root.Right, arr)</span><br></pre></td></tr></table></figure>

<p>对应的处理访问次序图为<br><img src="/images/tree/in-order-recursive-traversal.png" alt=""><br>按箭头上代表步骤的数字来依次查看，确实是按中序遍历（1 5 6 10）来处理节点的值。</p>
<h2 id="后序遍历：左-gt-右-gt-根"><a href="#后序遍历：左-gt-右-gt-根" class="headerlink" title="后序遍历：左-&gt;右-&gt;根"></a>后序遍历：左-&gt;右-&gt;根</h2><p>由于后序遍历是左-&gt;右-&gt;根，那么我们应该把函数放在访问左节点和右节点之后，也就是</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">traverse(root.Left, arr)</span><br><span class="line">traverse(root.Right, arr) </span><br><span class="line">handle(root.Value)</span><br></pre></td></tr></table></figure>

<p>对应的处理访问次序图为<br><img src="/images/tree/post-order-recursive-traversal.png" alt=""><br>按箭头上代表步骤的数字来依次查看，确实是按后序遍历（1 6 5）来处理节点的值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然二叉树的遍历方式有三种，但是实现起来其实代码是几乎一摸一样的， 我们以固定的顺序去拜访这些节点，区别只是处理节点的函数摆放的位置不同，先序是还未拜访左右子节点之前就调用处理函数，中序是拜访完左子节点就调用，后序是拜访完左右子节点再调用处理函数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
</search>
