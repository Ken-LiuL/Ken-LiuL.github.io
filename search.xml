<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python CookBook</title>
    <url>/2020/05/07/Python-CookBook/</url>
    <content><![CDATA[<p>Python是一门非常好作为入门学习的编程语言，语言简洁干练，拥有强大的第三方库，可以用来做机器学习、数据分析、爬虫等等。但是，很多人入门之后对Python的认知就停留在了比较浅显的认知上，成为了调包侠， Python本身有一些特性和库（如collections、future、generator等）是值得并且需要仔细来琢磨的。<a href="https://book.douban.com/subject/4828875/" target="_blank" rel="noopener">Python Cookbook</a> 就是一本可以作为进阶学习Python的书籍，里面的很多技巧和方法论非常实用。</p>
<a id="more"></a>

<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="序列分解"><a href="#序列分解" class="headerlink" title="序列分解"></a>序列分解</h2><p>任何的序列（或者是可迭代对象）可以通过一个简单的赋值操作来分解为单独的变量, 如果变量总数和序列里的元素数目不匹配会抛出ValueError，不过我们可以用*操作符来处理这种情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y, z = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = a</span><br><span class="line">ValueError: too many values to unpack (expected <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*x, y = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, *_, y = a  <span class="comment">#如果你想丢弃部分元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deque可以以O(1)的时间复杂度在头部和尾部进行append和pop的操作，既可以作为queue也可以作为stack来使用。</p>
<blockquote>
<p>Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.popleft()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="Heapq"><a href="#Heapq" class="headerlink" title="Heapq"></a>Heapq</h2><p>Heapq就是堆数据结构（也叫优先队列），他满足<strong>heap[k] &lt;= heap[2<em>k+1] and heap[k] &lt;= heap[2</em>k+2]</strong>, heapq是最小堆， heapq[0]得到的总是最小值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums)) <span class="comment"># Prints [42, 37, 23]</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums)) <span class="comment"># Prints [-4, 1, 2]</span></span><br><span class="line"><span class="comment">#优先队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._queue = []</span><br><span class="line">        self._index = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item, priority)</span>:</span></span><br><span class="line">        heapq.heappush(self._queue, (-priority, item, self._index))</span><br><span class="line">        self._index += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(self._queue)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>heap[0]和heapq.heappop()操作永远得到当前最小的元素，每次操作的时间复杂度仅仅为logN，所以当需要得到n个最小的元素并且n远远小于列表的长度的时候，通过heapq来实现是比较好的。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>常常我们想要一个key对应多个值，容易写出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> v <span class="keyword">in</span> d:</span><br><span class="line">    d[v].append()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    d[v] = []</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">d.setdefault(v, []).append()</span><br></pre></td></tr></table></figure>
<p>这样的代码块，setdefault相对方便一点，但是每次都要调用很繁琐，其实我们可以直接用<strong>defaultdict</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d = defaultdict()</span><br><span class="line">d[<span class="string">'test'</span>].append(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<p>而有的时候当我们迭代字典的时候希望能够保留插入的顺序，那么可以使用<strong>OrderedDict</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">d = OrderedDict()</span><br><span class="line">d[<span class="string">'test1'</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">'test2'</span>] = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure>
<p>如果要比较字典的键值的相同或者不同，也有方便的集合操作符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.keys() &amp; b.keys()   <span class="comment">#intersection</span></span><br><span class="line">a.keys() - b.keys()   <span class="comment">#difference</span></span><br><span class="line">a.items() &amp; b.items()</span><br><span class="line">a.items() - b.items()</span><br></pre></td></tr></table></figure>
<p>需要注意的是<strong>a.values()</strong>方法并不支持这样的集合操作。</p>
<h2 id="命名切片"><a href="#命名切片" class="headerlink" title="命名切片"></a>命名切片</h2><p>在做数据处理的时候，常常需要频繁的对序列进行切片，满屏幕的切片操作常常会让代码可读性大大降低，命名切片可以提高代码可读性和维护性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = slice(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>) <span class="comment">#start, stop, step</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[a]</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.indices(<span class="number">5</span>)       <span class="comment">#适配一个合适的范围</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="制表或者计数"><a href="#制表或者计数" class="headerlink" title="制表或者计数"></a>制表或者计数</h2><p>对于字典而言，一个常见的用法是，我们经常用来统计元素的频率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> dic:</span><br><span class="line">    <span class="keyword">if</span> e <span class="keyword">in</span> dic:</span><br><span class="line">        dic[e] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[e] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>不过其实python的<strong>Counter</strong>可以直接用来解决此类问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">fre = Counter(a)</span><br><span class="line">fre.most_common(<span class="number">3</span>)          <span class="comment">#top 3 出现的元素</span></span><br><span class="line"><span class="comment">#一个有意思的地方是，Counter可以直接做数学操作</span></span><br><span class="line">fre2 = Counter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">fre - fre2                 <span class="comment">#difference</span></span><br><span class="line">fre + fre2                 <span class="comment">#union</span></span><br></pre></td></tr></table></figure>
<h2 id="字典和对象排序"><a href="#字典和对象排序" class="headerlink" title="字典和对象排序"></a>字典和对象排序</h2><p>如果需要对数组字典进行排序的话，我们常常的做法是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted(data, key=<span class="keyword">lambda</span>...)</span><br></pre></td></tr></table></figure>
<p>python其实提供一个专门的函数来处理这种情况，<strong>itemgetter</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">sroted(data, key=itemgetter(<span class="string">'field1'</span>, <span class="string">'field2'</span>))</span><br><span class="line"><span class="comment">#min,max也可以使用</span></span><br><span class="line">max(l, key=itemgetter(<span class="string">'field1))</span></span><br></pre></td></tr></table></figure>
<p>类似得，如果是对数组对象进行排序的话，我们可以使用<strong>attrgetter</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line">sorted(users, key=attrgetter(<span class="string">'user_id'</span>))</span><br></pre></td></tr></table></figure>
<p>值得注意是，虽然两种做法都可以，但是来自operator的做法会更快一点</p>
<h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><p>常用的数据分组我们会用pandas来进行，其实python的itertools包也提供类似的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line">data.sort(key=itemgetter(<span class="string">'user_id'</span>))</span><br><span class="line">groupby(data, key=itemgetter(<span class="string">'user_id'</span>))</span><br></pre></td></tr></table></figure>
<p>值得注意的地方是，<strong>groupby</strong>的逻辑是检查连续的元素，所以事先我们需要对数据进行第一轮排序。</p>
<h2 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h2><p>数据过滤有很多做法，除去简单的for loop，我们可以使用过滤器、迭代器、生成器以及itertool里面的工具</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[n <span class="keyword">for</span> n <span class="keyword">in</span> l <span class="keyword">if</span> n &gt; <span class="number">0</span>]        <span class="comment">#list comprehension</span></span><br><span class="line">(n <span class="keyword">for</span> n <span class="keyword">in</span> l <span class="keyword">if</span> n &gt; <span class="number">0</span>)        <span class="comment">#generator </span></span><br><span class="line">list(filter(<span class="keyword">lambda</span> x:.., l))   <span class="comment">#filter</span></span><br><span class="line">[n <span class="keyword">if</span> n &gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">for</span> n <span class="keyword">in</span> l] <span class="comment">#transformation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = [ i &gt; <span class="number">5</span> <span class="keyword">for</span> i <span class="keyword">in</span> a]</span><br><span class="line">list(compress(a, b))            <span class="comment">#根据b中的布尔值过滤对应的元素</span></span><br></pre></td></tr></table></figure>
<h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><p>当需要频繁大量的通过下标来访问tuple的时候，我们可以使用namedtuple来提高程序的可读性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User = namedtuple(<span class="string">'User'</span>, [<span class="string">'user_id'</span>, <span class="string">'username'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = User(<span class="string">'no1'</span>, <span class="string">'jacky'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.username</span><br><span class="line">jacky</span><br></pre></td></tr></table></figure>
<h2 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h2><p>合并字典也是常见的操作之一，我们经常会写if代码块来做这样的工作，或者使用update方法，这样会创建一个新的字典，但是其实可以直接使用 ChainMap来处理字典的合并查询，合成的新对象只是两个字典逻辑上的合并，并没有新的字典对象被创造出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'z'</span>:<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">'y'</span>:<span class="number">2</span>, <span class="string">'z'</span>:<span class="number">4</span>&#125;</span><br><span class="line">b.update(a)        <span class="comment">#用a来覆盖b，相同的key的话，会采用a中的值  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">a = &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'z'</span>:<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">'y'</span>:<span class="number">2</span>, <span class="string">'z'</span>:<span class="number">4</span>&#125;</span><br><span class="line">c = ChainMap(a, b)   <span class="comment">#用a来覆盖b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ChainMap一个有意思的地方是可以很方便的作为编程语言作用域的处理</span></span><br><span class="line">env = ChainMap()</span><br><span class="line">env[<span class="string">'x'</span>] = <span class="number">1</span></span><br><span class="line">env = env.new_child()</span><br><span class="line">env[<span class="string">'x'</span>] = <span class="number">2</span></span><br><span class="line">env = env.new_child()</span><br><span class="line"><span class="comment">#现在env['x']等于2</span></span><br><span class="line">env = env.parents</span><br><span class="line"><span class="comment">#现在env['x']等于1</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><p>几乎所有有用的程序都会涉及到某些文本处理，不管是解析数据还是产生输出。 这一章将重点关注文本的操作处理，比如提取字符串，搜索，替换以及解析等。<br>##字符串分割匹配和搜索<br><strong>string</strong>对象的<strong>split</strong>方法适用范围比较狭窄，而<strong>re.split</strong>则可以适用更广范围的字符串分割</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"a   b   c"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.split(<span class="string">' '</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'c'</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, a)</span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="comment">#re.split还可以进行多字符分割</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'asdf fjdk; afed, fjek,asdf, foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[;,\s]\s*'</span>, a)</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">'fjdk'</span>, <span class="string">'afed'</span>, <span class="string">'fjek'</span>, <span class="string">'asdf'</span>, <span class="string">'foo'</span>]</span><br></pre></td></tr></table></figure>
<p>同理，对于<strong>replace</strong>方法，我们也可以使用<strong>re.sub</strong>来实现更高级的文本替代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>, <span class="string">r'\3-\1-\2'</span>, a)</span><br><span class="line"><span class="string">'Today is 2012-11-27. PyCon starts 2013-3-13.'</span></span><br><span class="line"><span class="comment">#我们还可以使用命名分组来实现上述的功能</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(?P&lt;month&gt;\d+)/(?P&lt;day&gt;\d+)/(?P&lt;year&gt;\d+)'</span>, <span class="string">r'\g&lt;year&gt;-\g&lt;month&gt;-\g&lt;day&gt;'</span>, a)</span><br><span class="line"><span class="string">'Today is 2012-11-27. PyCon starts 2013-3-13.'</span></span><br><span class="line"><span class="comment">#更高级点的用法， 是可以传入回掉函数来处理sub</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(\d+)\(\d+)\(\d+)'</span>, <span class="keyword">lambda</span> x:x, a)</span><br></pre></td></tr></table></figure>
<p>在匹配中我们可以用?如(.<em>?)来做最短匹配，也可以使用?:如(?:\d+)来指定一个非捕获匹配。<br>##字符串格式化<br>我们可以使用*</em>rjust()<strong>，</strong>ljust()** 以及 <strong>center()</strong> 来做字符串对齐，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.ljust(<span class="number">20</span>)</span><br><span class="line"><span class="string">'Hello World         '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.rjust(<span class="number">20</span>)</span><br><span class="line"><span class="string">'         Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.center(<span class="number">20</span>, <span class="string">'*'</span>)</span><br><span class="line"><span class="string">'****Hello World*****'</span></span><br></pre></td></tr></table></figure>

<p><strong>format()</strong> 也可以做到这一点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'&gt;20'</span>)</span><br><span class="line"><span class="string">'         Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'&lt;20'</span>)</span><br><span class="line"><span class="string">'Hello World         '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'^20'</span>)</span><br><span class="line"><span class="string">'    Hello World     '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'=&gt;20s'</span>)</span><br><span class="line"><span class="string">'=========Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;:&gt;10s&#125; &#123;:&gt;10s&#125;'</span>.format(<span class="string">'Hello'</span>, <span class="string">'World'</span>)</span><br><span class="line"><span class="string">'     Hello      World'</span></span><br></pre></td></tr></table></figure>

<p>而且，我们还可以通过<strong>textwrap</strong> 模块来控制输出字符串的列宽</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line">textwrap.fill(s, <span class="number">40</span>)</span><br><span class="line"><span class="comment">#还可以配合os.get_terminal_size()来格式化输出</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">col = os.get_terminal_size().columns</span><br><span class="line">textwrap.fill(s, col)</span><br></pre></td></tr></table></figure>
<h1 id="数字日期和时间"><a href="#数字日期和时间" class="headerlink" title="数字日期和时间"></a>数字日期和时间</h1><h2 id="数字的格式化"><a href="#数字的格式化" class="headerlink" title="数字的格式化"></a>数字的格式化</h2><p>如果需要对浮点数进行四舍五入，我们可以直接使用<strong>round</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.23</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.27</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1644</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="number">1640</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1655</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="number">1700</span></span><br></pre></td></tr></table></figure>
<p>众所周知，浮点数计算是会存在误差的，所以如果需要更精确的浮点数计算，我们可以使用<strong>Decimal</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Decimal(<span class="string">'4.2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Decimal(<span class="string">'2.1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a / b</span><br><span class="line">Decimal(<span class="string">'3.333333333333333333333333333'</span>)</span><br><span class="line"><span class="comment">#还可以控制计算的规范</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> localcontext</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="keyword">with</span> localcontext() <span class="keyword">as</span> ctx:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   ctx.prec = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   print(a / b)</span><br><span class="line"><span class="number">3.33</span></span><br></pre></td></tr></table></figure>
<p>数字进制进行转换的时候，我们常常使用<strong>bin()</strong> ， <strong>orc()</strong> 以及 <strong>hex()</strong> ， 但<strong>format</strong>也可以完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(x)</span><br><span class="line"><span class="string">'0b10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(x)</span><br><span class="line"><span class="string">'0o2322'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(x)</span><br><span class="line"><span class="string">'0x4d2'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'b'</span>)</span><br><span class="line"><span class="string">'10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'o'</span>)</span><br><span class="line"><span class="string">'2322'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'x'</span>)</span><br><span class="line"><span class="string">'4d2'</span></span><br><span class="line"><span class="comment">#反过来可以直接用int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> int(<span class="string">'10011010010'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h2 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h2><p><strong>random</strong> 模块有很多函数来进行随机选择或者生成元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice(values)  <span class="comment">#随机选择</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(values, <span class="number">3</span>) <span class="comment">#随机抽样</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle()   <span class="comment">#随机打乱</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">0</span>, <span class="number">10</span>) <span class="comment">#随机数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()  <span class="comment"># 0 - 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.getrandbits(<span class="number">2</span>) <span class="comment">#N bit 随机数</span></span><br></pre></td></tr></table></figure>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>python的datetime是一个模块，有好几个类用来进行时间和日期的操作</p>
<ul>
<li>date 日期类</li>
<li>time 时间类</li>
<li>datetime 日期时间</li>
<li>timedelta 表示时间差</li>
<li>tzinfo  时区信息</li>
<li>timezone  时区</li>
</ul>
<p>用datetime和timedelta可以进行时间计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta, datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">23</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a + timedelta(days=<span class="number">10</span>))</span><br><span class="line"><span class="number">2012</span><span class="number">-10</span><span class="number">-03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = datetime(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b - a</span><br><span class="line">datetime.timedelta(days=<span class="number">89</span>)</span><br></pre></td></tr></table></figure>
<p>字符串转为时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class="string">'2020-12-01 19:23:23'</span>, <span class="string">'%Y-%m-%d, %H:%M:%S'</span>)</span><br></pre></td></tr></table></figure>
<p>时间格式化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(now.strftime(<span class="string">'%a, %b %d %H:%M'</span>))</span><br></pre></td></tr></table></figure>
<p>时区的设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tz = timezone(timedelta(hours=<span class="number">8</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = now.astimezone(tz)</span><br></pre></td></tr></table></figure>
<p> 需要注意的一点是, <strong>strptime</strong> 性能并不好，并且关于时区的问题，最好是使用<strong>pytz</strong> 模块<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>central = timezone(<span class="string">'US/Central)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; now = central.localize(datetime.now()) #得到美国时区的当前时间</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;  now.astimezone(timezone('</span>Asia/Shanghai<span class="string">')) #得到上海时区</span></span><br></pre></td></tr></table></figure><br><strong>pytz</strong> 是一个第三方库，需要安装<br>#迭代器与生成器<br>迭代器其实就是实现了迭代协议的对象，任何一个实现了<strong>next</strong>方法的对象都是一个迭代器，我们常常会把<strong>iter</strong>也实现了，当调用iter(obj)的时候，其实就是调用了对象的<strong>iter</strong>方法 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.val = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.val += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.val &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">return</span> self.val</span><br><span class="line">it  = iter(Iter())</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> it:</span><br><span class="line">    print(it)</span><br></pre></td></tr></table></figure>
<p>那生成器是什么呢？<strong>yield</strong>就构建了一个生成器，生成器实现了迭代器协议</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_range</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range_():</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>上面的<strong>my_range</strong>就是一个生成器，调用<strong>my_range()</strong> 之后会返回一个Generator对象，这个对象就实现了迭代器协议，可以进行各种迭代器的操作。如果我们想要对实现了迭代器协议的对象进行切片操作的话，那么就需要使用<strong>itertools.islice()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.islice(g, <span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p><strong>itertools</strong> 中还有用于过滤数据的<strong>dropwhile</strong> 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dropwhile(<span class="keyword">lambda</span> x: x &lt; <span class="number">5</span>, a):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#会打印出来5, 6, 7, 8, 9</span></span><br><span class="line"><span class="comment">#dropwhile会从前往后读数据，直到遇到第一个False，那么就会输出后续的所有元素</span></span><br><span class="line"><span class="comment">#值得注意的是这里只会处理第一个False</span></span><br></pre></td></tr></table></figure>
<p><strong>itertools</strong> 中还有有很多有用的处理迭代器对象的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations, combinations, zip_longest, chain</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(permutations(a))    <span class="comment">#排列</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(combinations(a, <span class="number">2</span>))    <span class="comment">#组合</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip_longest([<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">#返回最长的zip结果，默认的zip是最短的</span></span><br><span class="line">&gt;&gt;&gt;chain([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]) <span class="comment">#从逻辑上组合多个迭代器对象，然后进行统一的操作</span></span><br></pre></td></tr></table></figure>
<p><strong>iter</strong> 还有一个用法是可以接受一个函数，和结尾标记作为输入参数，它会创建一个迭代器，然后不对调用该函数，直到返回的是结尾标记</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> iter(<span class="keyword">lambda</span> : a.pop(), <span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="Yield"><a href="#Yield" class="headerlink" title="Yield"></a>Yield</h2><p>我们可以通过<strong>yield</strong>来得到一个生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>
<p>如果需要嵌套生成器，那么需要使用<strong>yield from</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> gen()</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gen():</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>
<p><strong>yield</strong>的使用中，一个难点或者说容易产生误解的地方是，当他和<strong>send</strong>一起使用的时候</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">ys</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>   i = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>       a = <span class="keyword">yield</span> i</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">if</span> a &gt; <span class="number">10</span>:</span><br><span class="line"><span class="meta">... </span>           <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>       i = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ys()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(g.send(<span class="literal">None</span>))</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(g.send(<span class="number">1</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(g.send(<span class="number">20</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>首先<strong>next</strong>和<strong>send(None)</strong> 是等价的，所以<strong>g.send(None)</strong> 等价于 <strong>next(g)</strong> ，关键的地方在于<strong>a = yield i</strong>这一行是怎么执行的，当我们第一次调用<strong>g.send(None)</strong> 的时候， 程序会运行到<strong>yield i</strong>这里，也就是会把<strong>i</strong>的值，当然此时是0，返回出来，所以打印出来的结果为0，然后此时程序挂起，值得注意的是此时变量<strong>a</strong>并没有得到任何的赋值，然后当调用<strong>g.send(1)</strong> 的时候，程序恢复执行，把1赋值给<strong>a</strong>然后程序一直运行到下一个<strong>yield</strong>的地方，此时<strong>i</strong>为1，那么也就会把1返回出去并打印出来。当<strong>g.send(20)</strong>的时候，<strong>a</strong>被赋值为20，然后循环会退出，那么我们就看到<strong>StopIteration</strong>被抛出来了。</p>
<h1 id="文件与IO"><a href="#文件与IO" class="headerlink" title="文件与IO"></a>文件与IO</h1><h2 id="文件写入和打印"><a href="#文件写入和打印" class="headerlink" title="文件写入和打印"></a>文件写入和打印</h2><p><strong>print</strong>最常用的输出函数，当使用<strong>print</strong>的时候，我们可以使用<strong>sep</strong>和<strong>end</strong>两个关键字参数来格式化输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(<span class="string">'hello'</span>, <span class="string">'world'</span>, sep=<span class="string">','</span>, end=<span class="string">'!!\n'</span>)</span><br><span class="line">hello,world!!</span><br></pre></td></tr></table></figure>
<p>一个常见的写文件的方式为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file'</span>, <span class="string">'w+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们需要追加到既有的文件中，那就需要使用<strong>a</strong>模式，但是如果我们想要只有该文件不存在的时候才写入，一种方式是显示判断文件是否存在，另外一种方式是指定模式为<strong>x</strong><br>##字符串IO<br>可以使用<strong>io.StringIO()</strong>和<strong>io.BytesIO()</strong> 来创建类文件对象操作字符串数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = io.StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.write(<span class="string">'Hello World\n'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'This is a test'</span>, file=s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.getvalue()</span><br><span class="line"><span class="string">'Hello World\nThis is a test\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = io.BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.write(<span class="string">b'binary data'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.getvalue()</span><br><span class="line"><span class="string">b'binary data'</span></span><br></pre></td></tr></table></figure>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>mmap可以让我们想操作内存一样操作文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#打开一个文件，并且使用mmap映射到内存里</span></span><br><span class="line">mapped = mmap.mmap(os.open(filename, os.O_RDWR), os.path.getsize(filename), access=mmap.ACCESS_WRITE)</span><br><span class="line"><span class="comment">#如果第一个参数设为-1，那么映射的是一段匿名内存</span></span><br><span class="line"><span class="keyword">with</span> mmap.mmap(<span class="number">-1</span>, <span class="number">13</span>) <span class="keyword">as</span> mm:</span><br><span class="line">    mm.write(<span class="string">b'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>对于文件路径的操作，<strong>os.path</strong>提供了很多方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">'/users/test/data/data.csv'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.basename(path)</span><br><span class="line"><span class="string">'data.csv'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.dirname(path)</span><br><span class="line"><span class="string">'/users/test/data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">'/test'</span>, <span class="string">'data'</span>)</span><br><span class="line"><span class="string">'/test/data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exits(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.islink(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getsize(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getmtime(<span class="string">'/test/data'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">'/test'</span>)</span><br></pre></td></tr></table></figure>
<p>python3.4版本之后引入了<strong>pathlib</strong>这个包，用这个包可以让我们用更优雅的方式来处理文件路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#旧方式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"><span class="comment">#pathlib可以以面向对象的方式来调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base_dir = Path(__file__).resolve().parent.parent</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path = base_dir / <span class="string">'data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.is_dir()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.is_file()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.is_symlink()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path..absolute()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.exits()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment">#使用pathlib还可以直接读取文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path.read_text()</span><br></pre></td></tr></table></figure>
<p>相比较<strong>os.path</strong>的方式而言，<strong>pathlib</strong>显得更更干净利落</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>如果需要使用临时文件，我们可以自己显示的管理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp_file  = tempfile.mkstemp()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp_dir = tempfile.mkdtemp()</span><br></pre></td></tr></table></figure>
<p>但是这样仅仅是创建了临时的文件和文件夹，我们需要自己处理打开，关闭和删除操作，更好的方式是使用<strong>TemporaryFile</strong>或<strong>NamedTemporaryFile</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryFile, NamedTemporaryFile</span><br><span class="line"><span class="keyword">with</span> TemporaryFile(<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'test'</span>)</span><br><span class="line"><span class="comment">#如果使用NamedTemporaryFile的话，还会额外的分配临时文件的名字出来</span></span><br><span class="line"><span class="keyword">with</span> NamedTemporaryFile(<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.name)</span><br></pre></td></tr></table></figure>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="对象的显示"><a href="#对象的显示" class="headerlink" title="对象的显示"></a>对象的显示</h2><p>对于python的类而言，有三个函数可以指定其输出的时候的样子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="comment">#str()函数，或者print的时候调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#在控制台操作的时候打印出来的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#format()的时候调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="上下文管理协议"><a href="#上下文管理协议" class="headerlink" title="上下文管理协议"></a>上下文管理协议</h2><p>如果想要自己创建的类支持<strong>with</strong>语句的话，需要实现<strong>enter</strong> 和<strong>exit</strong>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#第一个参数是异常类型</span></span><br><span class="line">    <span class="comment">#第二个参数是异常值</span></span><br><span class="line">    <span class="comment">#第三个参数是stacktrace</span></span><br><span class="line">    <span class="comment">#如果返回True，异常会被清空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, tb)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p> 同时，我们也可以从contextlib库中来使用contextmanager更好的来做上下文管理<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> contextlib</span><br><span class="line"><span class="meta"> @contextlib.contextmanager</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">open_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    f = open(filename, <span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">yield</span> f</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open_file(<span class="string">'test'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.readlines()</span><br></pre></td></tr></table></figure><br> contextmanager会把yield之前的内容作为<strong>enter</strong>， yield之后的内容作为<strong>exit</strong>，yield返回的内容作为as</p>
<h2 id="节省内存的方式创建对象"><a href="#节省内存的方式创建对象" class="headerlink" title="节省内存的方式创建对象"></a>节省内存的方式创建对象</h2><p> 当我们使用<strong>slots</strong>的时候可以有效节省对象占用的内存，因为内部会用tuple而不是字典来存储对应的属性<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">   __slots__ = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b, c)</span>:</span></span><br><span class="line">       sefl.a = a</span><br><span class="line">       self.b = b</span><br><span class="line">       self.c = c</span><br></pre></td></tr></table></figure><br> 但是如果使用了<strong>slots</strong>会有两个限制，一个是不支持多继承，另外一个是无法再给是例添加属性</p>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>以_和<strong>开头的属性都可被视为私有属性，区别是</strong>开头的属性会被重命名，所以继承的话无法被覆盖，大部分情况用_开头即可表面这是一个内部属性<br>##属性访问<br>python中可以像java等面向对象的语言一样设置属性的<strong>getter</strong>和<strong>setter</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self._name =self.name</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._name = value</span><br></pre></td></tr></table></figure>
<p>往往当我们想要给属性的访问添加额外的逻辑，比如验证的时候，可以采用这种方式，但是除此之外就没必要了，python不是java</p>
<h2 id="延迟属性和描述器"><a href="#延迟属性和描述器" class="headerlink" title="延迟属性和描述器"></a>延迟属性和描述器</h2><p>当使用<strong>lazyproperty</strong>的时候，属性仅仅在第一次被获取的时候被计算，以后都是直接获取值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"><span class="meta">    @lazyproperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.pi * self.radius ** <span class="number">2</span></span><br><span class="line"><span class="comment">#这里的area仅会计算一次</span></span><br></pre></td></tr></table></figure>
<p>实现了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__set__</span><br><span class="line">__get__</span><br><span class="line">__delete__</span><br></pre></td></tr></table></figure>
<p>中任意一个方法的对象就叫做描述器，python中很多特性都使用到了描述器，可以更好实现封装和隐藏实现细节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositiveNum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span>  self._value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'No negative'</span>)</span><br><span class="line">        self._value = val</span><br></pre></td></tr></table></figure>
<p>上面的<strong>PositiveNum</strong>就是一个描述器，描述器作为其他类的类属性的时候，就会发挥他的作用了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>:</span></span><br><span class="line">    price = PositiveNum(<span class="string">'price'</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">apple = Apple()</span><br><span class="line">apple.price</span><br><span class="line"><span class="comment">#当我们访问这个price的时候，会去调用price.__get__方法</span></span><br><span class="line">apple.price = <span class="number">20</span></span><br><span class="line"><span class="comment">#当我们设置这个price的时候，会去调用price.__set__方法</span></span><br><span class="line">apple2 = Apple()</span><br><span class="line"><span class="comment">#但是这样会产生一个问题，由于price是类属性，新创建的apple2实例，</span></span><br><span class="line"><span class="comment">#price就是20，因为类属性共享</span></span><br></pre></td></tr></table></figure>
<p>python中属性的查找顺序是这样的，如果类和基类中有该属性且该属性为带有<strong>set</strong>的描述器（上面的price）就是这种情况，就调用对应的描述器的<strong>set</strong>和<strong>get</strong>方法，否则就是访问实例的字典。另外一点需要说明的是，实例的属性都放在<strong>dict</strong>里，类属性都放在<strong>dict</strong>里，实例的类型是<strong>class</strong>，那么我们可以这样处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositiveNum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, val)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.name] =  val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value has to be positive'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>:</span></span><br><span class="line">    price = PositiveNum(<span class="string">'price'</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.price = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">apple1 = Apple()</span><br><span class="line">apple1.price = <span class="number">20</span></span><br><span class="line">apple2 = Apple()</span><br><span class="line">apple2.price == <span class="number">1</span></span><br><span class="line"><span class="comment">#这里apple1和apple2的price是独立分开，不互相干扰的，</span></span><br><span class="line"><span class="comment">#当我们需要访问price的时候，由于在类级别拥有price描述器，所</span></span><br><span class="line"><span class="comment">#有的访问或者赋值都会转为去调用price.__set__或price.__get__，</span></span><br><span class="line"><span class="comment">#那既然还是调用__get__和__set__，为什么这一次不一样了？</span></span><br><span class="line"><span class="comment">#关键地方在            </span></span><br><span class="line"><span class="comment">#     instance.__dict__[self.name] =  val</span></span><br><span class="line"><span class="comment">#instance是属性的调用方，也就是apple1或者apple2，</span></span><br><span class="line"><span class="comment">#instance.__dict__就是例子的属性字典了，</span></span><br></pre></td></tr></table></figure>
<p><strong>所以描述器本质上就是切面编程的一种实现，可以把一些通用的操作提取出来，然后对对象的属性或方法做装饰</strong></p>
<h2 id="Method-amp-amp-Function"><a href="#Method-amp-amp-Function" class="headerlink" title="Method &amp;&amp; Function"></a>Method &amp;&amp; Function</h2><p>Python里面的函数分为类里面的方法和普通的函数，两者都是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Function</span><span class="params">(object)</span>:</span></span><br><span class="line">    . . .</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></span><br><span class="line">        <span class="string">"Simulate func_descr_get() in Objects/funcobject.c"</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> types.MethodType(self, obj)</span><br></pre></td></tr></table></figure>
<p>可以看到的是，首先无论是类方法还是普通函数，都是<strong>Function</strong>的一个对象，其次Function是一个描述器，这意味着，当作为类方法访问的时候，会去调用 <strong><strong>get</strong>方法</strong>，当用Class.Method的方式调用的时候，就直接返回函数自己，当使用Instance.Method的方式调用的时候，会返回<strong>types.MethodType(self, obj)</strong>，这个方法把函数绑定到类调用方的实例上，这样当该函数被调用的时候，会把<strong>obj</strong>作为第一个参数，也就是<strong>self</strong>作为参数穿进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.f</span><br><span class="line">&lt;bound method Test.f of &lt;__main__.Test object at <span class="number">0x10e622be0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.f.__func__</span><br><span class="line">&lt;function Test.f at <span class="number">0x10e754ea0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.f.__self__</span><br><span class="line">&lt;__main__.Test object at <span class="number">0x10e622be0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.f.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">method</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Test</span>.<span class="title">f</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">function</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Test</span>.<span class="title">f</span>.<span class="title">__self__</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> <span class="params">(most recent call last)</span>:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'function'</span> object has no attribute <span class="string">'__self__'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Test.f.__func__</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'function'</span> object has no attribute <span class="string">'__func__'</span></span><br></pre></td></tr></table></figure>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>python是计数垃圾回收机制， <strong>weakref</strong>可以让我们引用一个对象，但是这个对象的计数并不会增加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line">a = Test()</span><br><span class="line">c1 = sys.getrefcount(a) </span><br><span class="line">b =  weakfref.ref(a)</span><br><span class="line">c2  = sys.getrefcount(b)</span><br><span class="line">c1 == c2</span><br></pre></td></tr></table></figure>
<p>弱引用简单的来说，当它引用的对象存在时，则对象可用，当对象不存在时，就返回None，说明对象不存在。程序不会因为对象不在就报错。</p>
<h2 id="简化比较"><a href="#简化比较" class="headerlink" title="简化比较"></a>简化比较</h2><p>如果要让对象支持比较操作符，那么就要实现各种大于，小于，等于等内建方法，其实可以直接使用<strong>functools.total_ordering</strong>来简化操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> total_ordering</span><br><span class="line"><span class="meta">@total_ordering</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        self.val = v</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> other.val == self.val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.val &lt; other.val</span><br></pre></td></tr></table></figure>
<p><strong>total_ordering</strong>会自动生成其他的一些内建比较方法</p>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>Python中任何东西都是对象，包括数字，字符串，方法以及类， metaclass就是创建类对象的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.__instance = <span class="literal">None</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, clsdict)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, clsname, bases, clsdict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__instance = super().__call__(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Creating Test'</span>)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br></pre></td></tr></table></figure>
<p>当Python解释器加载代码的时候，发现Test类的metaclass是Singleton，此时便依然 次调用Singleton的<strong>new</strong>和<strong>init</strong>方法来创建Test类对象（此时，创建的是Test类，而不是Test的实例，而当运行到 <strong>t = Test()</strong> 的时候，我们需要得到一个Test实例，那么就会调用Singleton的<strong>call</strong>方法去创建实例。</p>
<p>##关于<strong>prepare</strong></p>
<blockquote>
<p>Preparing the class namespace Once the appropriate metaclass has been identified, then the class namespace is prepared. If the metaclass has a <strong>prepare</strong> attribute, it is called as namespace = metaclass.<strong>prepare</strong>(name, bases, **kwds) (where the additional keyword arguments, if any, come from the class definition).<br>If the metaclass has no <strong>prepare</strong> attribute, then the class namespace is initialised as an empty ordered mapping.</p>
</blockquote>
<h2 id="可选参数的元类"><a href="#可选参数的元类" class="headerlink" title="可选参数的元类"></a>可选参数的元类</h2><p>在构建元类的时候，我们还可以传入额外的参数，不过这些参数同时需要在<strong>prepare</strong>,<strong>init</strong>和<strong>new</strong>中指定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases, *, debug=False, sync=False)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__prepare__(name, bases)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, ns, *, debug=False, sync=False)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, name, bases, ns)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, ns, *, debug=False, sync=False)</span>:</span></span><br><span class="line">        super().__init__(name, bases, ns)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(metaclass=Meta, debug=True, sync=False)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>锁是并发编程里最基本的primitive</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> lock, counter</span><br><span class="line">    lock.acjquire()</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    lock.release()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> lock, counter</span><br><span class="line">    lock.acquire()</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者直接用with</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> lock, counter</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        counter += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>python中的Event是用来同步通知线程的，主要用到<strong>wait</strong>和<strong>set</strong>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(event)</span>:</span></span><br><span class="line">    print(<span class="string">'start'</span>)</span><br><span class="line">    event.wait()</span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    threading.Thread(target=test, args=(event,))</span><br><span class="line">    print(<span class="string">'init'</span>)</span><br><span class="line">    event.set()</span><br><span class="line"><span class="comment">#当在event.set()调用之前，调用event.wait()的线程会一直等待，等到event.set()调用</span></span><br><span class="line"><span class="comment">#之后，该线程就会继续执行</span></span><br></pre></td></tr></table></figure>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>条件量也是一种线程协调的方式，往往可以用于条件性的生产者消费者模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">cond = threading.Condition()</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    cond.acquire()</span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n++</span><br><span class="line">        cond.notify()</span><br><span class="line">        cond.wait()</span><br><span class="line">    cond.release()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cond.acquire()</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            cond.notify()</span><br><span class="line">            cond.wait()</span><br><span class="line">        cond.release()</span><br></pre></td></tr></table></figure>
<p>当调用<strong>notify</strong>的时候，其他等待的<strong>wait</strong>会被唤醒。这里其实有两个锁，一个锁是上层的<strong>acquire</strong>，一个是<strong>wait</strong>的时候会创建一个锁，基本运行的过程是这样的：</p>
<ol>
<li>当producer中acquire执行的时候，会获得Condition的锁A</li>
<li>当notify执行的时候，会尝试从队列中获取锁并释放掉，此时没有任何锁</li>
<li>当wait执行的时候，会定义锁B，加入队列，并且acquire， 然后释放锁A，再次获取锁B，陷入等待（如果被notify之后，会再次获取锁A）</li>
<li>consumer端获取了锁A，当consumer去notify的时候，会从队列中拿到锁B，释放掉</li>
<li>当consumer调用wait的时候，会定义锁C，放入队列，并且acquire，然后释放锁A，再次获取C，陷入等待，而由于consumer已经释放了锁B和锁A，producer会从acquire锁B中醒来，然后再成功获取锁A。</li>
</ol>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">timer = threading.Timer(<span class="number">5</span>, <span class="keyword">lambda</span> : print(<span class="string">'x'</span>))</span><br><span class="line">timer.start()</span><br><span class="line">``` </span><br><span class="line"><span class="comment">## 信号量</span></span><br><span class="line">semaphore是量化控制线程的一种手段</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span>  threading</span><br><span class="line">semaphore = threading.Semaphore(<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    semaphore.acquire()</span><br><span class="line">    print(<span class="string">'hi'</span>)</span><br><span class="line">    semaphore.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    t = threading.Thread(target=test, args=())</span><br><span class="line">    t.start()</span><br><span class="line"><span class="comment">#同一时间只会有五个线程运行</span></span><br></pre></td></tr></table></figure>
<h2 id="Queue生产者消费者"><a href="#Queue生产者消费者" class="headerlink" title="Queue生产者消费者"></a>Queue生产者消费者</h2><p>由于Queue的put和get是线程安全的，所以可以使用Queue很方便的实现生产者消费者模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        q.put(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = q.get()</span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>我们可以使用协程来替代系统线程实现并发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'count down for '</span>, n)</span><br><span class="line">        <span class="keyword">yield</span> </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span><span class="params">(n)</span>:</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; n:</span><br><span class="line">        print(<span class="string">'count up as '</span>, x)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._task_queue = deque()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_task</span><span class="params">(self, task)</span>:</span></span><br><span class="line">        self._task_queue.append(task)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> len(self._task_queue) &gt; <span class="number">0</span>:</span><br><span class="line">            task = self._task_queue.popleft()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                next(task)</span><br><span class="line">                self._task_queue.append(task)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">loop = EventLoop()</span><br><span class="line">loop.new_task(countdown(<span class="number">10</span>))</span><br><span class="line">loop.new_task(countdown(<span class="number">5</span>))</span><br><span class="line">loop.new_task(countup(<span class="number">15</span>))</span><br><span class="line">loop.new_task(countup(<span class="number">20</span>))</span><br><span class="line">loop.run()</span><br></pre></td></tr></table></figure>
<p>这里每一个任务都是一个协程，EventLoop就是调度器，这里的实现方式颇有点NodeJs的事件循环的意思</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Boyer-Moore 算法</title>
    <url>/2020/05/03/Boyer-Moore-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>今天在做Leetcode上的<a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">这道找到数组中的majority element</a>题目时候，发现了一个有意思的算法，Boyer-Moore算法，可以在不借助哈希表和排序的情况下，以O(n)的时间复杂度来解决这个问题。</p>
<a id="more"></a>

<h1 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>如果我们首先将数组进行排序，然后直接返回中间的数，那么这个数字肯定是majority element。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简洁， 时间复杂度为O(NlogN)， 空间复杂度为常数项。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>用哈希表记录下每个数字出现的次数，然后当某个数字出现的次数超过1/2的时候，就可以将其返回。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">     <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">         dict[n]++</span><br><span class="line">         <span class="keyword">if</span> dict[n] &gt; <span class="built_in">len</span>(nums) /<span class="number">2</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> n</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(N)，但是空间复杂度为O(N)，并且涉及到哈希表的读取写入和扩容，实际时间并不快。</p>
<h1 id="Boyer-Moore算法"><a href="#Boyer-Moore算法" class="headerlink" title="Boyer-Moore算法"></a>Boyer-Moore算法</h1><p>该算法可以用O(1)的空间复杂度和O(N)的时间复杂度来解决此类问题，最早在<a href="http://www.cs.rug.nl/~wim/pub/whh348.pdf" target="_blank" rel="noopener">这篇论文</a>被提出。我们先看看代码 </p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count, res := <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _,  n := <span class="keyword">range</span> nums[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">if</span> n == res &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            res = n</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以假设majority element为s， 那么数组可以视为[a…s…c…s…b..d…s…s]， 也就是各个s元素之间穿插着其他的元素，由于s的数量超过所有的元素加起来的数量，那么至少有两个s元素连在一起，那么上述的count最终肯定为非负数数，并且res就为我们要找的元素。<br>假设nums为</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<ol>
<li>res为5，遇到5， count++ 到1</li>
<li>遇到0，count– 到0</li>
<li>遇到0， res为0</li>
<li>遇到0，count++为1</li>
<li>遇到5， count– 到0</li>
<li>遇到0， count++ 为1</li>
<li>遇到0， count++ 为2</li>
<li>遇到5， count– 为1</li>
<li>返回0作为majority element</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Boyer-Moore算法虽然并不直观，但是有良好的时间复杂度和空间复杂度，并且实现的代码非常简洁干净，多思考算法所蕴含的逻辑有助于掌握该算法。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划问题的思路和技巧</title>
    <url>/2020/04/24/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%A7%E9%83%A8%E5%88%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>动态规划是算法中最常见的一类问题之一，其解题思路常常为，将大问题分解为小问题，并且建立起通过解决小问题到解决大问题的对应关系来得到最终的答案，一旦找了分解问题和合并小问题答案的方程，问题本身就迎刃而解。然而，对于具体实现来说，从找到对应关系到最优的实现方式之间往往有着一些小技巧，这篇文章主要展开讲讲如何用一套思维模式和技巧来解决优化大部分动态规划的问题。</p>
<a id="more"></a>
<p>我们以leetcode上这道<a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">easy的动态规划题</a>为例子来层层剖析如何切入这种类型的题目。</p>
<h1 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h1><p>由于强盗不能抢相邻的两间房子，那么对于任意一间房子i而言，强盗要么</p>
<ol>
<li>抢当前的，然后跳过i+1间房子</li>
<li>不抢当前的房子，然后抢i+1间房子</li>
</ol>
<p>也就是说，对于任意一间房子i来说，强盗都有两个选择，并且每次选择都会影响后面的选择和结果，这是动态规划题目一个非常典型的特征，每次决策都对下一次决策参加影响，对最后的结果起作用。那对于这个抢房子的问题来说，我们已经将这个大问题分解成了小问题，让dp(i)代表，当强盗从第i个房子开始抢， 他能得到的最大收益，那么存在下面等式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp(i) &#x3D;  max(dp(i+2)+house_value[i], dp(i+1))</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>当我们找到了问题分解之后的对应关系后，最简单的实现方式就是递归了</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="keyword">int</span> , i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="built_in">len</span>(nums) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max(robbery current, skip current)</span></span><br><span class="line">    <span class="keyword">return</span> max(helper(nums, i+<span class="number">2</span>)+nums[i], helper(nums, i+<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="memorization"><a href="#memorization" class="headerlink" title="memorization"></a>memorization</h1><p>递归是最简单的实现方式，不过上述的实现方式浪费了很多时间在重复计算上面，动态规划问题可以通过memorization的方式来实现优化。memorization就是用字典或者数组来记住计算过的结果来避免重复计算、提高速度，比较典型的应用就是斐波那契数列。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="keyword">int</span> , i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="built_in">len</span>(nums)<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dp[i] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max(robbery current, skip current)</span></span><br><span class="line">    val := max(helper(nums, i+<span class="number">2</span>)+nums[i], helper(nums, i+<span class="number">1</span>))</span><br><span class="line">    dp[i] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>递归往往可以退化为循环的实现方式，虽然时间复杂度是一样的，但是循环避免了大量调用栈的创建和函数调用的开销，所以往往会快一些，而且在动态规划问题中来看，循环的实现方式更简介，因为动态规划问题的本质就是在前后状态有依赖的前提下来进行状态的推导。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        dp[i] = max(dp[i+<span class="number">2</span>]+nums[i], dp[i+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们推导的公式是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp(i) &#x3D;  max(dp(i+2)+house_value[i], dp(i+1))</span><br></pre></td></tr></table></figure>
<p>所以，在for循环里面，我们是从数组的末尾开始到index为0为止，这也叫top-down。另外一种是down-top的方式，假如dp[i]代表的是当强盗当抢到第i个房子时， 他已经得到的最大收益，那么存在下面的等式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp(i) &#x3D; max(dp(i - 2) + house_value[i], dp(i - 1))</span><br></pre></td></tr></table></figure>
<p>本质上两种方式是一样的，只是建模的思维不同而已，具体到代码实现上会体现为循环推导的方向不一样，down-top则是从头开始，而不是从末尾。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(nums)+<span class="number">2</span>; i++ &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-2</span>]+nums[i<span class="number">-2</span>], dp[i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(nums) +  <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="减少空间复杂度"><a href="#减少空间复杂度" class="headerlink" title="减少空间复杂度"></a>减少空间复杂度</h1><p>动态规划问题往往会用一维数组或者矩阵来保存状态和进行状态推导，比如强盗问题中，我们用一维数组dp来实现memorization，但是其实仔细分析我们会发现，我们只需要两个变量就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">current &#x3D;  max(prev2 + house_value[i], prev1)</span><br></pre></td></tr></table></figure>
<p>由于每次我们都只依赖两个状态，分别代表dp[i-2] (或者dp[i+2) 和dp[i-1] （或者dp[i+1])，那么我们就可以只用两个变量来优化我们的空间复杂度， 然后每次循环让</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">prev2 = prev1</span><br><span class="line">prev1 = current</span><br></pre></td></tr></table></figure>

<p>迭代去更新这两个变量的值即可。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    prev1, prev2, curr := <span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        curr = max(prev2 + n, prev1)</span><br><span class="line">        prev1, prev2  = curr, prev1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，经过以上的步骤，我们最终可以以非常简洁的代码、低空间复杂度和时间复杂度来解决一个动态规划的问题。其实解决动态规划问题的关键就是找到问题分解之后的推导关系，剩下的实现部分就可以像上面一样一步步优化。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems" target="_blank" rel="noopener">https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>链表是否有环</title>
    <url>/2020/04/22/%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
    <content><![CDATA[<p>判断单链表是否有环，以及环的长度和环开始的地方是常见的面试题，如leetcode上的<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">判断是否有环</a>和<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">给出环的起点</a>，基本上这种问题的解决思路就是快慢指针，这里我们介绍下Brent’s Cycle Detection Algorithm， 思路其实就是快慢指针，但是略有不同。</p>
<a id="more"></a>
<h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>快慢指针的思路其实就是，快指针每次往前移动两次而慢指针每次移动一次，那么如果这个单链表存在环路的话，迟早快指针会和慢指针相遇，否则就不存在环路。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span>  || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Brent’s-Cycle-Detection-Algorithm"><a href="#Brent’s-Cycle-Detection-Algorithm" class="headerlink" title="Brent’s Cycle Detection Algorithm"></a>Brent’s Cycle Detection Algorithm</h1><p>Brent算法虽然也是用快慢两个指针来检测环，但是区别是快指针每次移动2^N次之后才去移动慢指针，比如，一开始快指针移动2步，然后去更新慢指针，然后4步、8步直到找到环路或者发现并不存在环路。Brent’s算法有两个优势，一个是算法常数上来说会快于传统的快慢指针（两者都是O(N))，另外一个是，当要求给出环路的长度的时候，Brent’s的算法在检测到环路的同时，就已经得到环路的长度了，不需要额外的计算，相当于了一个side effect。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    steps_taken, step_limit := <span class="number">0</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        steps_taken++</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> steps_taken == step_limit &#123;</span><br><span class="line">            steps_taken = <span class="number">0</span></span><br><span class="line">            step_limit *= <span class="number">2</span></span><br><span class="line">            slow = fast</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当算法结束的时候，steps_taken就是环的长度，这里面的逻辑是这样的，我们需要快速把slow和fast两个指针迭代进入环，只要slow和fast两个指针进入环中，此时只要移动快指针N步，当N大于等于环路的长度的时候，那么自然两个指针会相遇，记录快指针移动了多少步的变量steps_taken就是环路的长度了。</p>
<h1 id="环路的起点"><a href="#环路的起点" class="headerlink" title="环路的起点"></a>环路的起点</h1><p>如果我们同时需要直到环路从哪个node开始，如<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">leetcode中的这道题</a>，还需要一个些额外的逻辑来处理。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fast, slow = head, head</span><br><span class="line"><span class="keyword">for</span> steps_taken &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fast = fast.Next</span><br><span class="line">    steps_taken--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">    fast = fast.Next</span><br><span class="line">    slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<p>上面这段代码可以帮助我们找到作为环起点的node，这里初看可能有点不是很直观，但是内在的逻辑很简单。我们假设整个单链表的长度（节点数）为N， 环的长度为L，环的起点的index为I 那么第一个for循环跑完之后，fast指针位于L的位置， 由于<code>N = L + I</code>，那么快指针再走<strong>I</strong>步就到了loop的起点，此时慢指针处于0的位置，慢指针走<strong>I</strong>步也到了loop的起点， 所以在第二个loop里，我们让快慢指针同时往前走，如果他们相遇，就代表他们同步到达了loop的起点。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="http://www.siafoo.net/algorithm/11" target="_blank" rel="noopener">http://www.siafoo.net/algorithm/11</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树先序中序后序的非递归实现</title>
    <url>/2020/01/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>上一篇中我们讲到对于递归形式的实现，无论是先序、中序还是后序，代码都是统一形式，区别无非就是处理节点的函数位置不同，那么对于非递归的形式，是否也有统一的实现方式呢？</p>
<p>答案是肯定的，只不过如果要达到这种统一，需要引入一些额外的变量和代码进来。</p>
<a id="more"></a>
<h1 id="先序和中序遍历"><a href="#先序和中序遍历" class="headerlink" title="先序和中序遍历"></a>先序和中序遍历</h1><p>对于非递归的遍历方式而言，先序和中序是很容易找到统一的代码形式的</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tranverse</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	cur := root</span><br><span class="line">	s := newStack()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> || !s.isEmpty() &#123;</span><br><span class="line">            <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">                s.push(cur)</span><br><span class="line">                <span class="comment">//先序</span></span><br><span class="line">                <span class="comment">//handle(cur.Val)</span></span><br><span class="line">                cur = cur.Left</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment">//中序</span></span><br><span class="line">            <span class="comment">//handle(cur.Val)</span></span><br><span class="line">            cur = cur.Right</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码形式来看是统一的，先把节点放到stack里面， 然后当当前的节点为nil的时候，我们从stack里面把节点pop出来，唯一的区别是处理节点的函数放置位置会有所不同。</p>
<p><img src="/images/tree/simple-tree-nodes.png" alt=""><br>以上图为例子，stack中元素的变化为:</p>
<ol>
<li>[10] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//push 10</li>
<li>[10, 5] &nbsp;&nbsp;&nbsp;//push 5</li>
<li>[10, 5, 1] //push完1之后，cur == nil,会跳出循环</li>
<li>[10, 5]  &nbsp;&nbsp;&nbsp;//pop出1, 接下来cur设为1.right，也就是nil</li>
<li>[10] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //此时cur == nil, 会跳出循环, pop出5, cur为5.right, 也就是6</li>
<li>[10, 6]  &nbsp;&nbsp;&nbsp;&nbsp;//push6之后， cur == nil, 会跳出循环</li>
<li>[10] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//pop出6，接下来cur设为6.right，也就是nil</li>
<li>[] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//pop出10，接下来cur设为10.right, 也就是19</li>
<li>[19] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//push 19</li>
<li>[19, 17] &nbsp; //push 17之后，cur == nil，然后重复上面的步骤直到stack为空</li>
</ol>
<p>从观察stack， 我们可以看出来，只要处理元素的函数放在pop之后，那么就是中序，放在循环push里面就是先序。 但是用这个代码框架，我们没办法实现后序遍历，其核心原因是没有办法保存整个栈状态以及区分放到stack里面的元素是左节点还是右节点， 所以无论把处理函数放在哪个位置，都无法兼容后序遍历。</p>
<h1 id="统一的形式"><a href="#统一的形式" class="headerlink" title="统一的形式"></a>统一的形式</h1><p>如果我们可以有种办法来区分处理的是左节点还是右节点，那么就可以做到兼容后序遍历。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    cur := root</span><br><span class="line">    s := newStack()</span><br><span class="line">    pre := cur</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> || !s.isEmpty() &#123;</span><br><span class="line">        <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">//先序遍历</span></span><br><span class="line">            <span class="comment">//handle(cur.Val)</span></span><br><span class="line">            s.push(cur)</span><br><span class="line">            cur = cur.Left</span><br><span class="line">        &#125;                               </span><br><span class="line">        cur  = s.seek()  </span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">            <span class="comment">//  handle(cur.Val)</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        cur = cur.Right </span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">            pre = s.pop()</span><br><span class="line">            <span class="comment">//后序遍历</span></span><br><span class="line">            <span class="comment">//handle(pre.Val)</span></span><br><span class="line">            cur = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们添加了一个pre变量， pre指向的永远都是上一次pop出来的元素，然后核心的部分其实在这段代码</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">	pre = s.pop()   </span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="comment">//handle(pre.Val)</span></span><br><span class="line">	cur = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们并没有马上pop， 而是选择性pop，并用pre变量记录下上次pop的元素，用这样的方式来改变节点访问的顺序， 在这种遍历方式下，父节点会被访问两次, 第一次作为临时节点，我们拿到右节点，所以<code>cur = s.seek()</code> , 而不是pop， 然后我们通过 <code>cur = cur.Right</code>拿到右节点push到stack里面去进行处理，当进行到叶子节点也就是<code>cur == nil</code>判断的时候， 我们把节点pop出来，并且<code>pre = s.pop; cur = nil</code>，此时会再次去访问一次父节点<code>cur = s.seek()</code>，由于<code>cur=cur.Right; pre == cur</code>， 所以我们会把父节点此时pop出去。这里两次访问父节点， 其实模拟了递归方式里保存栈空间的操作，把父节点的信息保存下来了。</p>
<p>还是以上图为例， 当我们第一次跳出for循环之后，栈的变换为：</p>
<ol>
<li><p>[10, 5, 1]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为1 </span></span><br><span class="line">  <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为nil</span></span><br><span class="line"> <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">     pre = s.pop()  <span class="comment">//pre为 1 </span></span><br><span class="line">     <span class="comment">//后序遍历</span></span><br><span class="line">     <span class="comment">//handle(pre.Val)</span></span><br><span class="line">     cur = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>[10, 5]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为5, 第一次访问父节点</span></span><br><span class="line"> <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为6, pre为1</span></span><br><span class="line"> <span class="comment">//接下来会把cur push到stack里面去并跳出循环</span></span><br></pre></td></tr></table></figure></li>
<li><p>[10, 5, 6]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为6</span></span><br><span class="line"> <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为nil</span></span><br><span class="line"> <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">     pre = s.pop()  <span class="comment">//pre为 6 </span></span><br><span class="line">     <span class="comment">//后序遍历</span></span><br><span class="line">     <span class="comment">//handle(pre.Val)</span></span><br><span class="line">     cur = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>[10, 5]</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">cur  = s.seek() <span class="comment">//此时cur为5, 第二次访问父节点</span></span><br><span class="line"> <span class="comment">//中序遍历</span></span><br><span class="line"> <span class="comment">//if cur.Right != pre &#123;</span></span><br><span class="line">     <span class="comment">//  handle(cur.Val)</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"> cur = cur.Right  <span class="comment">//此时cur为6, pre 也为6</span></span><br><span class="line"> <span class="comment">//此时cur == pre, 代表右节点已经访问过了, 我们需要pop</span></span><br><span class="line"> <span class="keyword">if</span> cur == <span class="literal">nil</span> || cur == pre &#123;</span><br><span class="line">     pre = s.pop()  <span class="comment">//pre为 5 </span></span><br><span class="line">     <span class="comment">//后序遍历</span></span><br><span class="line">     <span class="comment">//handle(pre.Val)</span></span><br><span class="line">     cur = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>从上面的步骤我们可以看出来我们的代码清楚分离了各个节点处理的阶段，如果放在for循环里就是先序，如果放在seek后就是中序，如果放在pop后就是后序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的核心就是只有当前节点下面的子节点都访问过之后，我们才去pop，不然就用seek来获得节点和其子节点，这样该节点的信息依然保留在stack里面，其次，用额外的变量去记录上次访问过的节点，用来识别是否右子树已经访问过了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的先序中序后序递归实现</title>
    <url>/2020/01/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>二叉树常见的遍历方式有三种（除去Level Traversal，也就是广度优先遍历），分别为先序遍历，中序遍历和后序遍历，而实现方式既有递归的实现方式也有非递归的实现方式。当然，递归的实现方式是最简单的。</p>
<a id="more"></a>
<h1 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h1><p>二叉树的三种遍历方式为：</p>
<ul>
<li>先序遍历：根-&gt;左-&gt;右</li>
<li>中序遍历：左-&gt;根-&gt;右</li>
<li>后序遍历：左-&gt;右-&gt;根</li>
</ul>
<p><img src="/images/tree/simple-tree-nodes.png" alt=""></p>
<p>对于以上这样一个简单的二叉树，如果我们以不同的遍历方式输出节点的值，那么产生的值的顺序为：</p>
<ul>
<li>先序遍历：10 5 1 6 19 17 21</li>
<li>中序遍历：1 5 6 10 17 19 21</li>
<li>后序遍历：1 6 5 17 21 19 10</li>
</ul>
<p>不同的遍历方式输出的节点值的顺序不同</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>我们先来看一下一个标准的递归访问树节点的实现方式</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root ==  <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	traverse(root.Left, arr)</span><br><span class="line">	traverse(root.Right, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">treeTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> traverse(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很标准简洁的递归访问树节点的方式，具体的访问顺序如下图<br><img src="/images/tree/recursive-tree-traversal.png" alt=""></p>
<p>这里仅仅画出了从root到左子树的访问和返回顺序，右子树大致相同。箭头上黑色的数字代表进入下一层递归，比如当root代表值为10的节点时候，图中箭头上1代表</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">traverse(root.Left, arr)</span><br></pre></td></tr></table></figure>
<p>而箭头上红色的数字代表该层函数结束，返回上一层，比如当root代表值为1的节点的时候，图中箭头上的红色4代表</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> root ==  <span class="literal">nil</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>返回到上一层调用者的步骤。<br>我们通过观察可以发现，我们的递归函数以固定的顺序<strong>访问</strong>树中的每一个节点，但是三种不同的遍历方式要求<strong>处理/输出</strong>的节点的顺序却是不一样，那么如何能用这个统一的递归访问方式来得到不同顺序的处理结果呢？关键点就在处理函数（对节点进行处理的函数，最简单的就是将节点值输出到标准输出流println）的放置位置。</p>
<h1 id="统一的实现"><a href="#统一的实现" class="headerlink" title="统一的实现"></a>统一的实现</h1><h2 id="先序遍历：根-gt-左-gt-右"><a href="#先序遍历：根-gt-左-gt-右" class="headerlink" title="先序遍历：根-&gt;左-&gt;右"></a>先序遍历：根-&gt;左-&gt;右</h2><p>由于先序遍历是根-&gt;左-&gt;右，那么我们应该把函数放在访问左右节点之前，也就是</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">handle(root.Value)</span><br><span class="line">traverse(root.Left, arr)</span><br><span class="line">traverse(root.Right, arr)</span><br></pre></td></tr></table></figure>
<p>对应的处理访问次序图为<br><img src="/images/tree/pre-order-recursive-traversal.png" alt=""><br>显而易见，我们以先序(10 5 1 6)的方式处理节点的值。</p>
<h2 id="中序遍历：左-gt-根-gt-右"><a href="#中序遍历：左-gt-根-gt-右" class="headerlink" title="中序遍历：左-&gt;根-&gt;右"></a>中序遍历：左-&gt;根-&gt;右</h2><p>由于中序遍历是左-&gt;根-&gt;右，那么我们应该把函数放在访问左节点之前和右节点之前，也就是</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">traverse(root.Left, arr)</span><br><span class="line">handle(root.Value)</span><br><span class="line">traverse(root.Right, arr)</span><br></pre></td></tr></table></figure>

<p>对应的处理访问次序图为<br><img src="/images/tree/in-order-recursive-traversal.png" alt=""><br>按箭头上代表步骤的数字来依次查看，确实是按中序遍历（1 5 6 10）来处理节点的值。</p>
<h2 id="后序遍历：左-gt-右-gt-根"><a href="#后序遍历：左-gt-右-gt-根" class="headerlink" title="后序遍历：左-&gt;右-&gt;根"></a>后序遍历：左-&gt;右-&gt;根</h2><p>由于后序遍历是左-&gt;右-&gt;根，那么我们应该把函数放在访问左节点和右节点之后，也就是</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">traverse(root.Left, arr)</span><br><span class="line">traverse(root.Right, arr) </span><br><span class="line">handle(root.Value)</span><br></pre></td></tr></table></figure>

<p>对应的处理访问次序图为<br><img src="/images/tree/post-order-recursive-traversal.png" alt=""><br>按箭头上代表步骤的数字来依次查看，确实是按后序遍历（1 6 5）来处理节点的值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然二叉树的遍历方式有三种，但是实现起来其实代码是几乎一摸一样的， 我们以固定的顺序去拜访这些节点，区别只是处理节点的函数摆放的位置不同，先序是还未拜访左右子节点之前就调用处理函数，中序是拜访完左子节点就调用，后序是拜访完左右子节点再调用处理函数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
</search>
