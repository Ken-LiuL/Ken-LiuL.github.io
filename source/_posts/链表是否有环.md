---
title: 链表是否有环
date: 2020-04-22 18:35:05
tags:
categories:
description:
---


判断单链表是否有环，以及环的长度和环开始的地方是常见的面试题，如leetcode上的[判断是否有环](https://leetcode.com/problems/linked-list-cycle/)和[给出环的起点](https://leetcode.com/problems/linked-list-cycle-ii/)，基本上这种问题的解决思路就是快慢指针，这里我们介绍下Brent's Cycle Detection Algorithm， 思路其实就是快慢指针，但是略有不同。
<!-- more -->
# 快慢指针 

快慢指针的思路其实就是，快指针每次往前移动两次而慢指针每次移动一次，那么如果这个单链表存在环路的话，迟早快指针会和慢指针相遇，否则就不存在环路。
```Golang
func hasCycle(head *ListNode) bool {
    if head == nil  || head.Next == nil {
        return false
    }
    slow, fast := head, head.Next
    for slow != fast {
        if fast == nil || fast.Next == nil {
            return false
        }
        slow = slow.Next
        fast = fast.Next.Next
    }
    return true
}
```
# Brent's Cycle Detection Algorithm
Brent算法虽然也是用快慢两个指针来检测环，但是区别是快指针每次移动2^N次之后才去移动慢指针，比如，一开始快指针移动2步，然后去更新慢指针，然后4步、8步直到找到环路或者发现并不存在环路。Brent's算法有两个优势，一个是算法常数上来说会快于传统的快慢指针（两者都是O(N))，另外一个是，当要求给出环路的长度的时候，Brent's的算法在检测到环路的同时，就已经得到来环路的长度了，不需要额外的计算，相当于了一个side effect。
```Golang
func hasCycle(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return false
    }
    fast, slow := head, head
    steps_taken, step_limit := 0, 2
    for {
        if fast == nil {
            return false
        }
        fast = fast.Next
        steps_taken++
        if fast == slow {
            break
        }
        if steps_taken == step_limit {
            steps_taken = 0
            step_limit *= 2
            slow = fast
        }
    }
    return true
}

```
当算法结束的时候，steps_taken就是环的长度，这里面的逻辑是这样的，我们需要快速的把slow和fast两个指针快速的迭代进入环，只要当slow和fast两个指针已经进入环路中了，那么此时只要移动快指针N步，当N大于等于环路的长度的时候，那么自然两个指针会相遇，记录快指针移动了多少步的变量steps_taken就是环路的长度了。

# 环路的起点
如果我们同时需要直到环路从哪个node开始，如[leetcode这道题](https://leetcode.com/problems/linked-list-cycle-ii/)，还需要一个些额外的逻辑来处理。
```Golang
fast, slow = head, head
for steps_taken > 0 {
    fast = fast.Next
    steps_taken--
}
for fast != slow {
    fast = fast.Next
    slow = slow.Next
}
return slow
```
上面这段代码可以帮助我们找到作为环起点的node，这里的逻辑初看可能有点不是很直观，但是有他内在的逻辑。我们假设整个单链表的长度（节点数）为N， 环的长度为L，环的起点的index为I 那么第一个for循环跑完之后，fast指针位于L的位置， 由于```N = L + I```，那么快指针再走**I**步就到了loop的起点，此时慢指针处于0的位置，慢指针走**I**步也到了loop的起点， 所以在第二个loop里，我们让快慢指针同时往前走，如果他们相遇，就代表他们同步到达了loop的起点。
